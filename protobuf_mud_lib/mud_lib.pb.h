// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mud_lib.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mud_5flib_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mud_5flib_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mud_5flib_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mud_5flib_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mud_5flib_2eproto;
namespace mud {
class attribute;
class attributeDefaultTypeInternal;
extern attributeDefaultTypeInternal _attribute_default_instance_;
class character;
class characterDefaultTypeInternal;
extern characterDefaultTypeInternal _character_default_instance_;
class character_book;
class character_bookDefaultTypeInternal;
extern character_bookDefaultTypeInternal _character_book_default_instance_;
class direction;
class directionDefaultTypeInternal;
extern directionDefaultTypeInternal _direction_default_instance_;
class enemy;
class enemyDefaultTypeInternal;
extern enemyDefaultTypeInternal _enemy_default_instance_;
class enemy_book;
class enemy_bookDefaultTypeInternal;
extern enemy_bookDefaultTypeInternal _enemy_book_default_instance_;
class location;
class locationDefaultTypeInternal;
extern locationDefaultTypeInternal _location_default_instance_;
class player;
class playerDefaultTypeInternal;
extern playerDefaultTypeInternal _player_default_instance_;
class player_book;
class player_bookDefaultTypeInternal;
extern player_bookDefaultTypeInternal _player_book_default_instance_;
class tile;
class tileDefaultTypeInternal;
extern tileDefaultTypeInternal _tile_default_instance_;
class tile_book;
class tile_bookDefaultTypeInternal;
extern tile_bookDefaultTypeInternal _tile_book_default_instance_;
}  // namespace mud
PROTOBUF_NAMESPACE_OPEN
template<> ::mud::attribute* Arena::CreateMaybeMessage<::mud::attribute>(Arena*);
template<> ::mud::character* Arena::CreateMaybeMessage<::mud::character>(Arena*);
template<> ::mud::character_book* Arena::CreateMaybeMessage<::mud::character_book>(Arena*);
template<> ::mud::direction* Arena::CreateMaybeMessage<::mud::direction>(Arena*);
template<> ::mud::enemy* Arena::CreateMaybeMessage<::mud::enemy>(Arena*);
template<> ::mud::enemy_book* Arena::CreateMaybeMessage<::mud::enemy_book>(Arena*);
template<> ::mud::location* Arena::CreateMaybeMessage<::mud::location>(Arena*);
template<> ::mud::player* Arena::CreateMaybeMessage<::mud::player>(Arena*);
template<> ::mud::player_book* Arena::CreateMaybeMessage<::mud::player_book>(Arena*);
template<> ::mud::tile* Arena::CreateMaybeMessage<::mud::tile>(Arena*);
template<> ::mud::tile_book* Arena::CreateMaybeMessage<::mud::tile_book>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mud {

enum direction_direction_enum : int {
  direction_direction_enum_NORTH = 0,
  direction_direction_enum_SOUTH = 1,
  direction_direction_enum_EAST = 2,
  direction_direction_enum_WEST = 3,
  direction_direction_enum_direction_direction_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  direction_direction_enum_direction_direction_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool direction_direction_enum_IsValid(int value);
constexpr direction_direction_enum direction_direction_enum_direction_enum_MIN = direction_direction_enum_NORTH;
constexpr direction_direction_enum direction_direction_enum_direction_enum_MAX = direction_direction_enum_WEST;
constexpr int direction_direction_enum_direction_enum_ARRAYSIZE = direction_direction_enum_direction_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* direction_direction_enum_descriptor();
template<typename T>
inline const std::string& direction_direction_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, direction_direction_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function direction_direction_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    direction_direction_enum_descriptor(), enum_t_value);
}
inline bool direction_direction_enum_Parse(
    const std::string& name, direction_direction_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<direction_direction_enum>(
    direction_direction_enum_descriptor(), name, value);
}
enum attribute_attribute_name_enum : int {
  attribute_attribute_name_enum_LIFE = 0,
  attribute_attribute_name_enum_STRENGTH = 1,
  attribute_attribute_name_enum_AGILITY = 2,
  attribute_attribute_name_enum_INTELLIGENCE = 3,
  attribute_attribute_name_enum_attribute_attribute_name_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  attribute_attribute_name_enum_attribute_attribute_name_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool attribute_attribute_name_enum_IsValid(int value);
constexpr attribute_attribute_name_enum attribute_attribute_name_enum_attribute_name_enum_MIN = attribute_attribute_name_enum_LIFE;
constexpr attribute_attribute_name_enum attribute_attribute_name_enum_attribute_name_enum_MAX = attribute_attribute_name_enum_INTELLIGENCE;
constexpr int attribute_attribute_name_enum_attribute_name_enum_ARRAYSIZE = attribute_attribute_name_enum_attribute_name_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* attribute_attribute_name_enum_descriptor();
template<typename T>
inline const std::string& attribute_attribute_name_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, attribute_attribute_name_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function attribute_attribute_name_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    attribute_attribute_name_enum_descriptor(), enum_t_value);
}
inline bool attribute_attribute_name_enum_Parse(
    const std::string& name, attribute_attribute_name_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<attribute_attribute_name_enum>(
    attribute_attribute_name_enum_descriptor(), name, value);
}
enum character_character_state_enum : int {
  character_character_state_enum_NONE = 0,
  character_character_state_enum_WALKING = 1,
  character_character_state_enum_COMBAT = 2,
  character_character_state_enum_character_character_state_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  character_character_state_enum_character_character_state_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool character_character_state_enum_IsValid(int value);
constexpr character_character_state_enum character_character_state_enum_character_state_enum_MIN = character_character_state_enum_NONE;
constexpr character_character_state_enum character_character_state_enum_character_state_enum_MAX = character_character_state_enum_COMBAT;
constexpr int character_character_state_enum_character_state_enum_ARRAYSIZE = character_character_state_enum_character_state_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* character_character_state_enum_descriptor();
template<typename T>
inline const std::string& character_character_state_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, character_character_state_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function character_character_state_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    character_character_state_enum_descriptor(), enum_t_value);
}
inline bool character_character_state_enum_Parse(
    const std::string& name, character_character_state_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<character_character_state_enum>(
    character_character_state_enum_descriptor(), name, value);
}
enum tile_tile_type_enum : int {
  tile_tile_type_enum_EMPTY = 0,
  tile_tile_type_enum_WALL = 1,
  tile_tile_type_enum_TREE = 2,
  tile_tile_type_enum_PORTAL = 3,
  tile_tile_type_enum_tile_tile_type_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  tile_tile_type_enum_tile_tile_type_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool tile_tile_type_enum_IsValid(int value);
constexpr tile_tile_type_enum tile_tile_type_enum_tile_type_enum_MIN = tile_tile_type_enum_EMPTY;
constexpr tile_tile_type_enum tile_tile_type_enum_tile_type_enum_MAX = tile_tile_type_enum_PORTAL;
constexpr int tile_tile_type_enum_tile_type_enum_ARRAYSIZE = tile_tile_type_enum_tile_type_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* tile_tile_type_enum_descriptor();
template<typename T>
inline const std::string& tile_tile_type_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, tile_tile_type_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function tile_tile_type_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    tile_tile_type_enum_descriptor(), enum_t_value);
}
inline bool tile_tile_type_enum_Parse(
    const std::string& name, tile_tile_type_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<tile_tile_type_enum>(
    tile_tile_type_enum_descriptor(), name, value);
}
enum tile_resident_type_enum : int {
  tile_resident_type_enum_NOBODY = 0,
  tile_resident_type_enum_CHARACTER = 1,
  tile_resident_type_enum_ENEMY = 2,
  tile_resident_type_enum_tile_resident_type_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  tile_resident_type_enum_tile_resident_type_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool tile_resident_type_enum_IsValid(int value);
constexpr tile_resident_type_enum tile_resident_type_enum_resident_type_enum_MIN = tile_resident_type_enum_NOBODY;
constexpr tile_resident_type_enum tile_resident_type_enum_resident_type_enum_MAX = tile_resident_type_enum_ENEMY;
constexpr int tile_resident_type_enum_resident_type_enum_ARRAYSIZE = tile_resident_type_enum_resident_type_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* tile_resident_type_enum_descriptor();
template<typename T>
inline const std::string& tile_resident_type_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, tile_resident_type_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function tile_resident_type_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    tile_resident_type_enum_descriptor(), enum_t_value);
}
inline bool tile_resident_type_enum_Parse(
    const std::string& name, tile_resident_type_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<tile_resident_type_enum>(
    tile_resident_type_enum_descriptor(), name, value);
}
// ===================================================================

class player :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.player) */ {
 public:
  player();
  virtual ~player();

  player(const player& from);
  player(player&& from) noexcept
    : player() {
    *this = ::std::move(from);
  }

  inline player& operator=(const player& from) {
    CopyFrom(from);
    return *this;
  }
  inline player& operator=(player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const player* internal_default_instance() {
    return reinterpret_cast<const player*>(
               &_player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(player& a, player& b) {
    a.Swap(&b);
  }
  inline void Swap(player* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline player* New() const final {
    return CreateMaybeMessage<player>(nullptr);
  }

  player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<player>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const player& from);
  void MergeFrom(const player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(player* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.player";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdCharactersFieldNumber = 4,
    kNameFieldNumber = 1,
    kPasswordHashFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // repeated int64 id_characters = 4;
  int id_characters_size() const;
  private:
  int _internal_id_characters_size() const;
  public:
  void clear_id_characters();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_characters(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_id_characters() const;
  void _internal_add_id_characters(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_id_characters();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 id_characters(int index) const;
  void set_id_characters(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_id_characters(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      id_characters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_id_characters();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string password_hash = 2;
  void clear_password_hash();
  const std::string& password_hash() const;
  void set_password_hash(const std::string& value);
  void set_password_hash(std::string&& value);
  void set_password_hash(const char* value);
  void set_password_hash(const char* value, size_t size);
  std::string* mutable_password_hash();
  std::string* release_password_hash();
  void set_allocated_password_hash(std::string* password_hash);
  private:
  const std::string& _internal_password_hash() const;
  void _internal_set_password_hash(const std::string& value);
  std::string* _internal_mutable_password_hash();
  public:

  // int64 id = 3;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.player)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > id_characters_;
  mutable std::atomic<int> _id_characters_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_hash_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class direction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.direction) */ {
 public:
  direction();
  virtual ~direction();

  direction(const direction& from);
  direction(direction&& from) noexcept
    : direction() {
    *this = ::std::move(from);
  }

  inline direction& operator=(const direction& from) {
    CopyFrom(from);
    return *this;
  }
  inline direction& operator=(direction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const direction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const direction* internal_default_instance() {
    return reinterpret_cast<const direction*>(
               &_direction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(direction& a, direction& b) {
    a.Swap(&b);
  }
  inline void Swap(direction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline direction* New() const final {
    return CreateMaybeMessage<direction>(nullptr);
  }

  direction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<direction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const direction& from);
  void MergeFrom(const direction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(direction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.direction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef direction_direction_enum direction_enum;
  static constexpr direction_enum NORTH =
    direction_direction_enum_NORTH;
  static constexpr direction_enum SOUTH =
    direction_direction_enum_SOUTH;
  static constexpr direction_enum EAST =
    direction_direction_enum_EAST;
  static constexpr direction_enum WEST =
    direction_direction_enum_WEST;
  static inline bool direction_enum_IsValid(int value) {
    return direction_direction_enum_IsValid(value);
  }
  static constexpr direction_enum direction_enum_MIN =
    direction_direction_enum_direction_enum_MIN;
  static constexpr direction_enum direction_enum_MAX =
    direction_direction_enum_direction_enum_MAX;
  static constexpr int direction_enum_ARRAYSIZE =
    direction_direction_enum_direction_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  direction_enum_descriptor() {
    return direction_direction_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& direction_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, direction_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function direction_enum_Name.");
    return direction_direction_enum_Name(enum_t_value);
  }
  static inline bool direction_enum_Parse(const std::string& name,
      direction_enum* value) {
    return direction_direction_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .mud.direction.direction_enum value = 1;
  void clear_value();
  ::mud::direction_direction_enum value() const;
  void set_value(::mud::direction_direction_enum value);
  private:
  ::mud::direction_direction_enum _internal_value() const;
  void _internal_set_value(::mud::direction_direction_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.direction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class attribute :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.attribute) */ {
 public:
  attribute();
  virtual ~attribute();

  attribute(const attribute& from);
  attribute(attribute&& from) noexcept
    : attribute() {
    *this = ::std::move(from);
  }

  inline attribute& operator=(const attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline attribute& operator=(attribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const attribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const attribute* internal_default_instance() {
    return reinterpret_cast<const attribute*>(
               &_attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(attribute& a, attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(attribute* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline attribute* New() const final {
    return CreateMaybeMessage<attribute>(nullptr);
  }

  attribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<attribute>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const attribute& from);
  void MergeFrom(const attribute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(attribute* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.attribute";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef attribute_attribute_name_enum attribute_name_enum;
  static constexpr attribute_name_enum LIFE =
    attribute_attribute_name_enum_LIFE;
  static constexpr attribute_name_enum STRENGTH =
    attribute_attribute_name_enum_STRENGTH;
  static constexpr attribute_name_enum AGILITY =
    attribute_attribute_name_enum_AGILITY;
  static constexpr attribute_name_enum INTELLIGENCE =
    attribute_attribute_name_enum_INTELLIGENCE;
  static inline bool attribute_name_enum_IsValid(int value) {
    return attribute_attribute_name_enum_IsValid(value);
  }
  static constexpr attribute_name_enum attribute_name_enum_MIN =
    attribute_attribute_name_enum_attribute_name_enum_MIN;
  static constexpr attribute_name_enum attribute_name_enum_MAX =
    attribute_attribute_name_enum_attribute_name_enum_MAX;
  static constexpr int attribute_name_enum_ARRAYSIZE =
    attribute_attribute_name_enum_attribute_name_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  attribute_name_enum_descriptor() {
    return attribute_attribute_name_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& attribute_name_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, attribute_name_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function attribute_name_enum_Name.");
    return attribute_attribute_name_enum_Name(enum_t_value);
  }
  static inline bool attribute_name_enum_Parse(const std::string& name,
      attribute_name_enum* value) {
    return attribute_attribute_name_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
    kRegenFieldNumber = 3,
  };
  // .mud.attribute.attribute_name_enum name = 1;
  void clear_name();
  ::mud::attribute_attribute_name_enum name() const;
  void set_name(::mud::attribute_attribute_name_enum value);
  private:
  ::mud::attribute_attribute_name_enum _internal_name() const;
  void _internal_set_name(::mud::attribute_attribute_name_enum value);
  public:

  // int32 value = 2;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 regen = 3;
  void clear_regen();
  ::PROTOBUF_NAMESPACE_ID::int32 regen() const;
  void set_regen(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_regen() const;
  void _internal_set_regen(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.attribute)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int name_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  ::PROTOBUF_NAMESPACE_ID::int32 regen_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class character :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.character) */ {
 public:
  character();
  virtual ~character();

  character(const character& from);
  character(character&& from) noexcept
    : character() {
    *this = ::std::move(from);
  }

  inline character& operator=(const character& from) {
    CopyFrom(from);
    return *this;
  }
  inline character& operator=(character&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const character& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const character* internal_default_instance() {
    return reinterpret_cast<const character*>(
               &_character_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(character& a, character& b) {
    a.Swap(&b);
  }
  inline void Swap(character* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline character* New() const final {
    return CreateMaybeMessage<character>(nullptr);
  }

  character* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<character>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const character& from);
  void MergeFrom(const character& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(character* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.character";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef character_character_state_enum character_state_enum;
  static constexpr character_state_enum NONE =
    character_character_state_enum_NONE;
  static constexpr character_state_enum WALKING =
    character_character_state_enum_WALKING;
  static constexpr character_state_enum COMBAT =
    character_character_state_enum_COMBAT;
  static inline bool character_state_enum_IsValid(int value) {
    return character_character_state_enum_IsValid(value);
  }
  static constexpr character_state_enum character_state_enum_MIN =
    character_character_state_enum_character_state_enum_MIN;
  static constexpr character_state_enum character_state_enum_MAX =
    character_character_state_enum_character_state_enum_MAX;
  static constexpr int character_state_enum_ARRAYSIZE =
    character_character_state_enum_character_state_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  character_state_enum_descriptor() {
    return character_character_state_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& character_state_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, character_state_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function character_state_enum_Name.");
    return character_character_state_enum_Name(enum_t_value);
  }
  static inline bool character_state_enum_Parse(const std::string& name,
      character_state_enum* value) {
    return character_character_state_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 5,
    kNameFieldNumber = 1,
    kFacingFieldNumber = 4,
    kIdFieldNumber = 2,
    kTileIdFieldNumber = 3,
    kStateFieldNumber = 6,
  };
  // repeated .mud.attribute attributes = 5;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::mud::attribute* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >*
      mutable_attributes();
  private:
  const ::mud::attribute& _internal_attributes(int index) const;
  ::mud::attribute* _internal_add_attributes();
  public:
  const ::mud::attribute& attributes(int index) const;
  ::mud::attribute* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >&
      attributes() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mud.direction facing = 4;
  bool has_facing() const;
  private:
  bool _internal_has_facing() const;
  public:
  void clear_facing();
  const ::mud::direction& facing() const;
  ::mud::direction* release_facing();
  ::mud::direction* mutable_facing();
  void set_allocated_facing(::mud::direction* facing);
  private:
  const ::mud::direction& _internal_facing() const;
  ::mud::direction* _internal_mutable_facing();
  public:

  // int64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 tile_id = 3;
  void clear_tile_id();
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id() const;
  void set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tile_id() const;
  void _internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.character.character_state_enum state = 6;
  void clear_state();
  ::mud::character_character_state_enum state() const;
  void set_state(::mud::character_character_state_enum value);
  private:
  ::mud::character_character_state_enum _internal_state() const;
  void _internal_set_state(::mud::character_character_state_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.character)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute > attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mud::direction* facing_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class enemy :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.enemy) */ {
 public:
  enemy();
  virtual ~enemy();

  enemy(const enemy& from);
  enemy(enemy&& from) noexcept
    : enemy() {
    *this = ::std::move(from);
  }

  inline enemy& operator=(const enemy& from) {
    CopyFrom(from);
    return *this;
  }
  inline enemy& operator=(enemy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const enemy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const enemy* internal_default_instance() {
    return reinterpret_cast<const enemy*>(
               &_enemy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(enemy& a, enemy& b) {
    a.Swap(&b);
  }
  inline void Swap(enemy* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline enemy* New() const final {
    return CreateMaybeMessage<enemy>(nullptr);
  }

  enemy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<enemy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const enemy& from);
  void MergeFrom(const enemy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(enemy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.enemy";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 5,
    kNameFieldNumber = 1,
    kFacingFieldNumber = 4,
    kIdFieldNumber = 2,
    kTileIdFieldNumber = 3,
  };
  // repeated .mud.attribute attributes = 5;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::mud::attribute* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >*
      mutable_attributes();
  private:
  const ::mud::attribute& _internal_attributes(int index) const;
  ::mud::attribute* _internal_add_attributes();
  public:
  const ::mud::attribute& attributes(int index) const;
  ::mud::attribute* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >&
      attributes() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .mud.direction facing = 4;
  bool has_facing() const;
  private:
  bool _internal_has_facing() const;
  public:
  void clear_facing();
  const ::mud::direction& facing() const;
  ::mud::direction* release_facing();
  ::mud::direction* mutable_facing();
  void set_allocated_facing(::mud::direction* facing);
  private:
  const ::mud::direction& _internal_facing() const;
  ::mud::direction* _internal_mutable_facing();
  public:

  // int64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 tile_id = 3;
  void clear_tile_id();
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id() const;
  void set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tile_id() const;
  void _internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.enemy)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute > attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::mud::direction* facing_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 tile_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class location :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.location) */ {
 public:
  location();
  virtual ~location();

  location(const location& from);
  location(location&& from) noexcept
    : location() {
    *this = ::std::move(from);
  }

  inline location& operator=(const location& from) {
    CopyFrom(from);
    return *this;
  }
  inline location& operator=(location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const location* internal_default_instance() {
    return reinterpret_cast<const location*>(
               &_location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(location& a, location& b) {
    a.Swap(&b);
  }
  inline void Swap(location* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline location* New() const final {
    return CreateMaybeMessage<location>(nullptr);
  }

  location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<location>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const location& from);
  void MergeFrom(const location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(location* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.location";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // .mud.direction direction = 1;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::mud::direction& direction() const;
  ::mud::direction* release_direction();
  ::mud::direction* mutable_direction();
  void set_allocated_direction(::mud::direction* direction);
  private:
  const ::mud::direction& _internal_direction() const;
  ::mud::direction* _internal_mutable_direction();
  public:

  // int64 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.location)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::mud::direction* direction_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class tile :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.tile) */ {
 public:
  tile();
  virtual ~tile();

  tile(const tile& from);
  tile(tile&& from) noexcept
    : tile() {
    *this = ::std::move(from);
  }

  inline tile& operator=(const tile& from) {
    CopyFrom(from);
    return *this;
  }
  inline tile& operator=(tile&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const tile& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tile* internal_default_instance() {
    return reinterpret_cast<const tile*>(
               &_tile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(tile& a, tile& b) {
    a.Swap(&b);
  }
  inline void Swap(tile* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline tile* New() const final {
    return CreateMaybeMessage<tile>(nullptr);
  }

  tile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<tile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const tile& from);
  void MergeFrom(const tile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.tile";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef tile_tile_type_enum tile_type_enum;
  static constexpr tile_type_enum EMPTY =
    tile_tile_type_enum_EMPTY;
  static constexpr tile_type_enum WALL =
    tile_tile_type_enum_WALL;
  static constexpr tile_type_enum TREE =
    tile_tile_type_enum_TREE;
  static constexpr tile_type_enum PORTAL =
    tile_tile_type_enum_PORTAL;
  static inline bool tile_type_enum_IsValid(int value) {
    return tile_tile_type_enum_IsValid(value);
  }
  static constexpr tile_type_enum tile_type_enum_MIN =
    tile_tile_type_enum_tile_type_enum_MIN;
  static constexpr tile_type_enum tile_type_enum_MAX =
    tile_tile_type_enum_tile_type_enum_MAX;
  static constexpr int tile_type_enum_ARRAYSIZE =
    tile_tile_type_enum_tile_type_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  tile_type_enum_descriptor() {
    return tile_tile_type_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& tile_type_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, tile_type_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function tile_type_enum_Name.");
    return tile_tile_type_enum_Name(enum_t_value);
  }
  static inline bool tile_type_enum_Parse(const std::string& name,
      tile_type_enum* value) {
    return tile_tile_type_enum_Parse(name, value);
  }

  typedef tile_resident_type_enum resident_type_enum;
  static constexpr resident_type_enum NOBODY =
    tile_resident_type_enum_NOBODY;
  static constexpr resident_type_enum CHARACTER =
    tile_resident_type_enum_CHARACTER;
  static constexpr resident_type_enum ENEMY =
    tile_resident_type_enum_ENEMY;
  static inline bool resident_type_enum_IsValid(int value) {
    return tile_resident_type_enum_IsValid(value);
  }
  static constexpr resident_type_enum resident_type_enum_MIN =
    tile_resident_type_enum_resident_type_enum_MIN;
  static constexpr resident_type_enum resident_type_enum_MAX =
    tile_resident_type_enum_resident_type_enum_MAX;
  static constexpr int resident_type_enum_ARRAYSIZE =
    tile_resident_type_enum_resident_type_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  resident_type_enum_descriptor() {
    return tile_resident_type_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& resident_type_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, resident_type_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function resident_type_enum_Name.");
    return tile_resident_type_enum_Name(enum_t_value);
  }
  static inline bool resident_type_enum_Parse(const std::string& name,
      resident_type_enum* value) {
    return tile_resident_type_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNeighboursFieldNumber = 6,
    kMoodFieldNumber = 5,
    kIdFieldNumber = 1,
    kTypeFieldNumber = 2,
    kOccupantTypeFieldNumber = 3,
    kOccupantIdFieldNumber = 4,
  };
  // repeated .mud.location neighbours = 6;
  int neighbours_size() const;
  private:
  int _internal_neighbours_size() const;
  public:
  void clear_neighbours();
  ::mud::location* mutable_neighbours(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::location >*
      mutable_neighbours();
  private:
  const ::mud::location& _internal_neighbours(int index) const;
  ::mud::location* _internal_add_neighbours();
  public:
  const ::mud::location& neighbours(int index) const;
  ::mud::location* add_neighbours();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::location >&
      neighbours() const;

  // string mood = 5;
  void clear_mood();
  const std::string& mood() const;
  void set_mood(const std::string& value);
  void set_mood(std::string&& value);
  void set_mood(const char* value);
  void set_mood(const char* value, size_t size);
  std::string* mutable_mood();
  std::string* release_mood();
  void set_allocated_mood(std::string* mood);
  private:
  const std::string& _internal_mood() const;
  void _internal_set_mood(const std::string& value);
  std::string* _internal_mutable_mood();
  public:

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.tile.tile_type_enum type = 2;
  void clear_type();
  ::mud::tile_tile_type_enum type() const;
  void set_type(::mud::tile_tile_type_enum value);
  private:
  ::mud::tile_tile_type_enum _internal_type() const;
  void _internal_set_type(::mud::tile_tile_type_enum value);
  public:

  // .mud.tile.resident_type_enum occupant_type = 3;
  void clear_occupant_type();
  ::mud::tile_resident_type_enum occupant_type() const;
  void set_occupant_type(::mud::tile_resident_type_enum value);
  private:
  ::mud::tile_resident_type_enum _internal_occupant_type() const;
  void _internal_set_occupant_type(::mud::tile_resident_type_enum value);
  public:

  // int64 occupant_id = 4;
  void clear_occupant_id();
  ::PROTOBUF_NAMESPACE_ID::int64 occupant_id() const;
  void set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_occupant_id() const;
  void _internal_set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.tile)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::location > neighbours_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mood_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  int type_;
  int occupant_type_;
  ::PROTOBUF_NAMESPACE_ID::int64 occupant_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class player_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.player_book) */ {
 public:
  player_book();
  virtual ~player_book();

  player_book(const player_book& from);
  player_book(player_book&& from) noexcept
    : player_book() {
    *this = ::std::move(from);
  }

  inline player_book& operator=(const player_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline player_book& operator=(player_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const player_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const player_book* internal_default_instance() {
    return reinterpret_cast<const player_book*>(
               &_player_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(player_book& a, player_book& b) {
    a.Swap(&b);
  }
  inline void Swap(player_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline player_book* New() const final {
    return CreateMaybeMessage<player_book>(nullptr);
  }

  player_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<player_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const player_book& from);
  void MergeFrom(const player_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(player_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.player_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .mud.player players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::mud::player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >*
      mutable_players();
  private:
  const ::mud::player& _internal_players(int index) const;
  ::mud::player* _internal_add_players();
  public:
  const ::mud::player& players(int index) const;
  ::mud::player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >&
      players() const;

  // @@protoc_insertion_point(class_scope:mud.player_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player > players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class tile_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.tile_book) */ {
 public:
  tile_book();
  virtual ~tile_book();

  tile_book(const tile_book& from);
  tile_book(tile_book&& from) noexcept
    : tile_book() {
    *this = ::std::move(from);
  }

  inline tile_book& operator=(const tile_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline tile_book& operator=(tile_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const tile_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tile_book* internal_default_instance() {
    return reinterpret_cast<const tile_book*>(
               &_tile_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(tile_book& a, tile_book& b) {
    a.Swap(&b);
  }
  inline void Swap(tile_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline tile_book* New() const final {
    return CreateMaybeMessage<tile_book>(nullptr);
  }

  tile_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<tile_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const tile_book& from);
  void MergeFrom(const tile_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tile_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.tile_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 1,
  };
  // repeated .mud.tile tiles = 1;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::mud::tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >*
      mutable_tiles();
  private:
  const ::mud::tile& _internal_tiles(int index) const;
  ::mud::tile* _internal_add_tiles();
  public:
  const ::mud::tile& tiles(int index) const;
  ::mud::tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >&
      tiles() const;

  // @@protoc_insertion_point(class_scope:mud.tile_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile > tiles_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class character_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.character_book) */ {
 public:
  character_book();
  virtual ~character_book();

  character_book(const character_book& from);
  character_book(character_book&& from) noexcept
    : character_book() {
    *this = ::std::move(from);
  }

  inline character_book& operator=(const character_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline character_book& operator=(character_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const character_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const character_book* internal_default_instance() {
    return reinterpret_cast<const character_book*>(
               &_character_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(character_book& a, character_book& b) {
    a.Swap(&b);
  }
  inline void Swap(character_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline character_book* New() const final {
    return CreateMaybeMessage<character_book>(nullptr);
  }

  character_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<character_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const character_book& from);
  void MergeFrom(const character_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(character_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.character_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 1,
  };
  // repeated .mud.character characters = 1;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::mud::character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
      mutable_characters();
  private:
  const ::mud::character& _internal_characters(int index) const;
  ::mud::character* _internal_add_characters();
  public:
  const ::mud::character& characters(int index) const;
  ::mud::character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
      characters() const;

  // @@protoc_insertion_point(class_scope:mud.character_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character > characters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// -------------------------------------------------------------------

class enemy_book :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.enemy_book) */ {
 public:
  enemy_book();
  virtual ~enemy_book();

  enemy_book(const enemy_book& from);
  enemy_book(enemy_book&& from) noexcept
    : enemy_book() {
    *this = ::std::move(from);
  }

  inline enemy_book& operator=(const enemy_book& from) {
    CopyFrom(from);
    return *this;
  }
  inline enemy_book& operator=(enemy_book&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const enemy_book& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const enemy_book* internal_default_instance() {
    return reinterpret_cast<const enemy_book*>(
               &_enemy_book_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(enemy_book& a, enemy_book& b) {
    a.Swap(&b);
  }
  inline void Swap(enemy_book* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline enemy_book* New() const final {
    return CreateMaybeMessage<enemy_book>(nullptr);
  }

  enemy_book* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<enemy_book>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const enemy_book& from);
  void MergeFrom(const enemy_book& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(enemy_book* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.enemy_book";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5flib_2eproto);
    return ::descriptor_table_mud_5flib_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnemiesFieldNumber = 1,
  };
  // repeated .mud.enemy enemies = 1;
  int enemies_size() const;
  private:
  int _internal_enemies_size() const;
  public:
  void clear_enemies();
  ::mud::enemy* mutable_enemies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >*
      mutable_enemies();
  private:
  const ::mud::enemy& _internal_enemies(int index) const;
  ::mud::enemy* _internal_add_enemies();
  public:
  const ::mud::enemy& enemies(int index) const;
  ::mud::enemy* add_enemies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >&
      enemies() const;

  // @@protoc_insertion_point(class_scope:mud.enemy_book)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy > enemies_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5flib_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// player

// string name = 1;
inline void player::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& player::name() const {
  // @@protoc_insertion_point(field_get:mud.player.name)
  return _internal_name();
}
inline void player::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.player.name)
}
inline std::string* player::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.player.name)
  return _internal_mutable_name();
}
inline const std::string& player::_internal_name() const {
  return name_.GetNoArena();
}
inline void player::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void player::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.player.name)
}
inline void player::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.player.name)
}
inline void player::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.player.name)
}
inline std::string* player::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* player::release_name() {
  // @@protoc_insertion_point(field_release:mud.player.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.player.name)
}

// string password_hash = 2;
inline void player::clear_password_hash() {
  password_hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& player::password_hash() const {
  // @@protoc_insertion_point(field_get:mud.player.password_hash)
  return _internal_password_hash();
}
inline void player::set_password_hash(const std::string& value) {
  _internal_set_password_hash(value);
  // @@protoc_insertion_point(field_set:mud.player.password_hash)
}
inline std::string* player::mutable_password_hash() {
  // @@protoc_insertion_point(field_mutable:mud.player.password_hash)
  return _internal_mutable_password_hash();
}
inline const std::string& player::_internal_password_hash() const {
  return password_hash_.GetNoArena();
}
inline void player::_internal_set_password_hash(const std::string& value) {
  
  password_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void player::set_password_hash(std::string&& value) {
  
  password_hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.player.password_hash)
}
inline void player::set_password_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.player.password_hash)
}
inline void player::set_password_hash(const char* value, size_t size) {
  
  password_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.player.password_hash)
}
inline std::string* player::_internal_mutable_password_hash() {
  
  return password_hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* player::release_password_hash() {
  // @@protoc_insertion_point(field_release:mud.player.password_hash)
  
  return password_hash_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void player::set_allocated_password_hash(std::string* password_hash) {
  if (password_hash != nullptr) {
    
  } else {
    
  }
  password_hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password_hash);
  // @@protoc_insertion_point(field_set_allocated:mud.player.password_hash)
}

// int64 id = 3;
inline void player::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::id() const {
  // @@protoc_insertion_point(field_get:mud.player.id)
  return _internal_id();
}
inline void player::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void player::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.player.id)
}

// repeated int64 id_characters = 4;
inline int player::_internal_id_characters_size() const {
  return id_characters_.size();
}
inline int player::id_characters_size() const {
  return _internal_id_characters_size();
}
inline void player::clear_id_characters() {
  id_characters_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::_internal_id_characters(int index) const {
  return id_characters_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 player::id_characters(int index) const {
  // @@protoc_insertion_point(field_get:mud.player.id_characters)
  return _internal_id_characters(index);
}
inline void player::set_id_characters(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  id_characters_.Set(index, value);
  // @@protoc_insertion_point(field_set:mud.player.id_characters)
}
inline void player::_internal_add_id_characters(::PROTOBUF_NAMESPACE_ID::int64 value) {
  id_characters_.Add(value);
}
inline void player::add_id_characters(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_id_characters(value);
  // @@protoc_insertion_point(field_add:mud.player.id_characters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
player::_internal_id_characters() const {
  return id_characters_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
player::id_characters() const {
  // @@protoc_insertion_point(field_list:mud.player.id_characters)
  return _internal_id_characters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
player::_internal_mutable_id_characters() {
  return &id_characters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
player::mutable_id_characters() {
  // @@protoc_insertion_point(field_mutable_list:mud.player.id_characters)
  return _internal_mutable_id_characters();
}

// -------------------------------------------------------------------

// direction

// .mud.direction.direction_enum value = 1;
inline void direction::clear_value() {
  value_ = 0;
}
inline ::mud::direction_direction_enum direction::_internal_value() const {
  return static_cast< ::mud::direction_direction_enum >(value_);
}
inline ::mud::direction_direction_enum direction::value() const {
  // @@protoc_insertion_point(field_get:mud.direction.value)
  return _internal_value();
}
inline void direction::_internal_set_value(::mud::direction_direction_enum value) {
  
  value_ = value;
}
inline void direction::set_value(::mud::direction_direction_enum value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mud.direction.value)
}

// -------------------------------------------------------------------

// attribute

// .mud.attribute.attribute_name_enum name = 1;
inline void attribute::clear_name() {
  name_ = 0;
}
inline ::mud::attribute_attribute_name_enum attribute::_internal_name() const {
  return static_cast< ::mud::attribute_attribute_name_enum >(name_);
}
inline ::mud::attribute_attribute_name_enum attribute::name() const {
  // @@protoc_insertion_point(field_get:mud.attribute.name)
  return _internal_name();
}
inline void attribute::_internal_set_name(::mud::attribute_attribute_name_enum value) {
  
  name_ = value;
}
inline void attribute::set_name(::mud::attribute_attribute_name_enum value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.attribute.name)
}

// int32 value = 2;
inline void attribute::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 attribute::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 attribute::value() const {
  // @@protoc_insertion_point(field_get:mud.attribute.value)
  return _internal_value();
}
inline void attribute::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
}
inline void attribute::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:mud.attribute.value)
}

// int32 regen = 3;
inline void attribute::clear_regen() {
  regen_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 attribute::_internal_regen() const {
  return regen_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 attribute::regen() const {
  // @@protoc_insertion_point(field_get:mud.attribute.regen)
  return _internal_regen();
}
inline void attribute::_internal_set_regen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  regen_ = value;
}
inline void attribute::set_regen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_regen(value);
  // @@protoc_insertion_point(field_set:mud.attribute.regen)
}

// -------------------------------------------------------------------

// character

// string name = 1;
inline void character::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& character::name() const {
  // @@protoc_insertion_point(field_get:mud.character.name)
  return _internal_name();
}
inline void character::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.character.name)
}
inline std::string* character::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.character.name)
  return _internal_mutable_name();
}
inline const std::string& character::_internal_name() const {
  return name_.GetNoArena();
}
inline void character::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void character::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.character.name)
}
inline void character::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.character.name)
}
inline void character::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.character.name)
}
inline std::string* character::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* character::release_name() {
  // @@protoc_insertion_point(field_release:mud.character.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void character::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.character.name)
}

// int64 id = 2;
inline void character::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::id() const {
  // @@protoc_insertion_point(field_get:mud.character.id)
  return _internal_id();
}
inline void character::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void character::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.character.id)
}

// int64 tile_id = 3;
inline void character::clear_tile_id() {
  tile_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::_internal_tile_id() const {
  return tile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 character::tile_id() const {
  // @@protoc_insertion_point(field_get:mud.character.tile_id)
  return _internal_tile_id();
}
inline void character::_internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tile_id_ = value;
}
inline void character::set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tile_id(value);
  // @@protoc_insertion_point(field_set:mud.character.tile_id)
}

// .mud.direction facing = 4;
inline bool character::_internal_has_facing() const {
  return this != internal_default_instance() && facing_ != nullptr;
}
inline bool character::has_facing() const {
  return _internal_has_facing();
}
inline void character::clear_facing() {
  if (GetArenaNoVirtual() == nullptr && facing_ != nullptr) {
    delete facing_;
  }
  facing_ = nullptr;
}
inline const ::mud::direction& character::_internal_facing() const {
  const ::mud::direction* p = facing_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::direction*>(
      &::mud::_direction_default_instance_);
}
inline const ::mud::direction& character::facing() const {
  // @@protoc_insertion_point(field_get:mud.character.facing)
  return _internal_facing();
}
inline ::mud::direction* character::release_facing() {
  // @@protoc_insertion_point(field_release:mud.character.facing)
  
  ::mud::direction* temp = facing_;
  facing_ = nullptr;
  return temp;
}
inline ::mud::direction* character::_internal_mutable_facing() {
  
  if (facing_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::direction>(GetArenaNoVirtual());
    facing_ = p;
  }
  return facing_;
}
inline ::mud::direction* character::mutable_facing() {
  // @@protoc_insertion_point(field_mutable:mud.character.facing)
  return _internal_mutable_facing();
}
inline void character::set_allocated_facing(::mud::direction* facing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete facing_;
  }
  if (facing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      facing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, facing, submessage_arena);
    }
    
  } else {
    
  }
  facing_ = facing;
  // @@protoc_insertion_point(field_set_allocated:mud.character.facing)
}

// repeated .mud.attribute attributes = 5;
inline int character::_internal_attributes_size() const {
  return attributes_.size();
}
inline int character::attributes_size() const {
  return _internal_attributes_size();
}
inline void character::clear_attributes() {
  attributes_.Clear();
}
inline ::mud::attribute* character::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mud.character.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >*
character::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mud.character.attributes)
  return &attributes_;
}
inline const ::mud::attribute& character::_internal_attributes(int index) const {
  return attributes_.Get(index);
}
inline const ::mud::attribute& character::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mud.character.attributes)
  return _internal_attributes(index);
}
inline ::mud::attribute* character::_internal_add_attributes() {
  return attributes_.Add();
}
inline ::mud::attribute* character::add_attributes() {
  // @@protoc_insertion_point(field_add:mud.character.attributes)
  return _internal_add_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >&
character::attributes() const {
  // @@protoc_insertion_point(field_list:mud.character.attributes)
  return attributes_;
}

// .mud.character.character_state_enum state = 6;
inline void character::clear_state() {
  state_ = 0;
}
inline ::mud::character_character_state_enum character::_internal_state() const {
  return static_cast< ::mud::character_character_state_enum >(state_);
}
inline ::mud::character_character_state_enum character::state() const {
  // @@protoc_insertion_point(field_get:mud.character.state)
  return _internal_state();
}
inline void character::_internal_set_state(::mud::character_character_state_enum value) {
  
  state_ = value;
}
inline void character::set_state(::mud::character_character_state_enum value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:mud.character.state)
}

// -------------------------------------------------------------------

// enemy

// string name = 1;
inline void enemy::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& enemy::name() const {
  // @@protoc_insertion_point(field_get:mud.enemy.name)
  return _internal_name();
}
inline void enemy::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.enemy.name)
}
inline std::string* enemy::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.enemy.name)
  return _internal_mutable_name();
}
inline const std::string& enemy::_internal_name() const {
  return name_.GetNoArena();
}
inline void enemy::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void enemy::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.enemy.name)
}
inline void enemy::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.enemy.name)
}
inline void enemy::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.enemy.name)
}
inline std::string* enemy::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* enemy::release_name() {
  // @@protoc_insertion_point(field_release:mud.enemy.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void enemy::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.enemy.name)
}

// int64 id = 2;
inline void enemy::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::id() const {
  // @@protoc_insertion_point(field_get:mud.enemy.id)
  return _internal_id();
}
inline void enemy::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void enemy::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.enemy.id)
}

// int64 tile_id = 3;
inline void enemy::clear_tile_id() {
  tile_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::_internal_tile_id() const {
  return tile_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 enemy::tile_id() const {
  // @@protoc_insertion_point(field_get:mud.enemy.tile_id)
  return _internal_tile_id();
}
inline void enemy::_internal_set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  tile_id_ = value;
}
inline void enemy::set_tile_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tile_id(value);
  // @@protoc_insertion_point(field_set:mud.enemy.tile_id)
}

// .mud.direction facing = 4;
inline bool enemy::_internal_has_facing() const {
  return this != internal_default_instance() && facing_ != nullptr;
}
inline bool enemy::has_facing() const {
  return _internal_has_facing();
}
inline void enemy::clear_facing() {
  if (GetArenaNoVirtual() == nullptr && facing_ != nullptr) {
    delete facing_;
  }
  facing_ = nullptr;
}
inline const ::mud::direction& enemy::_internal_facing() const {
  const ::mud::direction* p = facing_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::direction*>(
      &::mud::_direction_default_instance_);
}
inline const ::mud::direction& enemy::facing() const {
  // @@protoc_insertion_point(field_get:mud.enemy.facing)
  return _internal_facing();
}
inline ::mud::direction* enemy::release_facing() {
  // @@protoc_insertion_point(field_release:mud.enemy.facing)
  
  ::mud::direction* temp = facing_;
  facing_ = nullptr;
  return temp;
}
inline ::mud::direction* enemy::_internal_mutable_facing() {
  
  if (facing_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::direction>(GetArenaNoVirtual());
    facing_ = p;
  }
  return facing_;
}
inline ::mud::direction* enemy::mutable_facing() {
  // @@protoc_insertion_point(field_mutable:mud.enemy.facing)
  return _internal_mutable_facing();
}
inline void enemy::set_allocated_facing(::mud::direction* facing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete facing_;
  }
  if (facing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      facing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, facing, submessage_arena);
    }
    
  } else {
    
  }
  facing_ = facing;
  // @@protoc_insertion_point(field_set_allocated:mud.enemy.facing)
}

// repeated .mud.attribute attributes = 5;
inline int enemy::_internal_attributes_size() const {
  return attributes_.size();
}
inline int enemy::attributes_size() const {
  return _internal_attributes_size();
}
inline void enemy::clear_attributes() {
  attributes_.Clear();
}
inline ::mud::attribute* enemy::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mud.enemy.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >*
enemy::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mud.enemy.attributes)
  return &attributes_;
}
inline const ::mud::attribute& enemy::_internal_attributes(int index) const {
  return attributes_.Get(index);
}
inline const ::mud::attribute& enemy::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mud.enemy.attributes)
  return _internal_attributes(index);
}
inline ::mud::attribute* enemy::_internal_add_attributes() {
  return attributes_.Add();
}
inline ::mud::attribute* enemy::add_attributes() {
  // @@protoc_insertion_point(field_add:mud.enemy.attributes)
  return _internal_add_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::attribute >&
enemy::attributes() const {
  // @@protoc_insertion_point(field_list:mud.enemy.attributes)
  return attributes_;
}

// -------------------------------------------------------------------

// location

// .mud.direction direction = 1;
inline bool location::_internal_has_direction() const {
  return this != internal_default_instance() && direction_ != nullptr;
}
inline bool location::has_direction() const {
  return _internal_has_direction();
}
inline void location::clear_direction() {
  if (GetArenaNoVirtual() == nullptr && direction_ != nullptr) {
    delete direction_;
  }
  direction_ = nullptr;
}
inline const ::mud::direction& location::_internal_direction() const {
  const ::mud::direction* p = direction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::mud::direction*>(
      &::mud::_direction_default_instance_);
}
inline const ::mud::direction& location::direction() const {
  // @@protoc_insertion_point(field_get:mud.location.direction)
  return _internal_direction();
}
inline ::mud::direction* location::release_direction() {
  // @@protoc_insertion_point(field_release:mud.location.direction)
  
  ::mud::direction* temp = direction_;
  direction_ = nullptr;
  return temp;
}
inline ::mud::direction* location::_internal_mutable_direction() {
  
  if (direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::mud::direction>(GetArenaNoVirtual());
    direction_ = p;
  }
  return direction_;
}
inline ::mud::direction* location::mutable_direction() {
  // @@protoc_insertion_point(field_mutable:mud.location.direction)
  return _internal_mutable_direction();
}
inline void location::set_allocated_direction(::mud::direction* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete direction_;
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    
  } else {
    
  }
  direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:mud.location.direction)
}

// int64 id = 2;
inline void location::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 location::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 location::id() const {
  // @@protoc_insertion_point(field_get:mud.location.id)
  return _internal_id();
}
inline void location::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void location::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.location.id)
}

// -------------------------------------------------------------------

// tile

// int64 id = 1;
inline void tile::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::id() const {
  // @@protoc_insertion_point(field_get:mud.tile.id)
  return _internal_id();
}
inline void tile::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
}
inline void tile::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:mud.tile.id)
}

// .mud.tile.tile_type_enum type = 2;
inline void tile::clear_type() {
  type_ = 0;
}
inline ::mud::tile_tile_type_enum tile::_internal_type() const {
  return static_cast< ::mud::tile_tile_type_enum >(type_);
}
inline ::mud::tile_tile_type_enum tile::type() const {
  // @@protoc_insertion_point(field_get:mud.tile.type)
  return _internal_type();
}
inline void tile::_internal_set_type(::mud::tile_tile_type_enum value) {
  
  type_ = value;
}
inline void tile::set_type(::mud::tile_tile_type_enum value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:mud.tile.type)
}

// .mud.tile.resident_type_enum occupant_type = 3;
inline void tile::clear_occupant_type() {
  occupant_type_ = 0;
}
inline ::mud::tile_resident_type_enum tile::_internal_occupant_type() const {
  return static_cast< ::mud::tile_resident_type_enum >(occupant_type_);
}
inline ::mud::tile_resident_type_enum tile::occupant_type() const {
  // @@protoc_insertion_point(field_get:mud.tile.occupant_type)
  return _internal_occupant_type();
}
inline void tile::_internal_set_occupant_type(::mud::tile_resident_type_enum value) {
  
  occupant_type_ = value;
}
inline void tile::set_occupant_type(::mud::tile_resident_type_enum value) {
  _internal_set_occupant_type(value);
  // @@protoc_insertion_point(field_set:mud.tile.occupant_type)
}

// int64 occupant_id = 4;
inline void tile::clear_occupant_id() {
  occupant_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::_internal_occupant_id() const {
  return occupant_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 tile::occupant_id() const {
  // @@protoc_insertion_point(field_get:mud.tile.occupant_id)
  return _internal_occupant_id();
}
inline void tile::_internal_set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  occupant_id_ = value;
}
inline void tile::set_occupant_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_occupant_id(value);
  // @@protoc_insertion_point(field_set:mud.tile.occupant_id)
}

// string mood = 5;
inline void tile::clear_mood() {
  mood_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& tile::mood() const {
  // @@protoc_insertion_point(field_get:mud.tile.mood)
  return _internal_mood();
}
inline void tile::set_mood(const std::string& value) {
  _internal_set_mood(value);
  // @@protoc_insertion_point(field_set:mud.tile.mood)
}
inline std::string* tile::mutable_mood() {
  // @@protoc_insertion_point(field_mutable:mud.tile.mood)
  return _internal_mutable_mood();
}
inline const std::string& tile::_internal_mood() const {
  return mood_.GetNoArena();
}
inline void tile::_internal_set_mood(const std::string& value) {
  
  mood_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void tile::set_mood(std::string&& value) {
  
  mood_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.tile.mood)
}
inline void tile::set_mood(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mood_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.tile.mood)
}
inline void tile::set_mood(const char* value, size_t size) {
  
  mood_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.tile.mood)
}
inline std::string* tile::_internal_mutable_mood() {
  
  return mood_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* tile::release_mood() {
  // @@protoc_insertion_point(field_release:mud.tile.mood)
  
  return mood_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void tile::set_allocated_mood(std::string* mood) {
  if (mood != nullptr) {
    
  } else {
    
  }
  mood_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mood);
  // @@protoc_insertion_point(field_set_allocated:mud.tile.mood)
}

// repeated .mud.location neighbours = 6;
inline int tile::_internal_neighbours_size() const {
  return neighbours_.size();
}
inline int tile::neighbours_size() const {
  return _internal_neighbours_size();
}
inline void tile::clear_neighbours() {
  neighbours_.Clear();
}
inline ::mud::location* tile::mutable_neighbours(int index) {
  // @@protoc_insertion_point(field_mutable:mud.tile.neighbours)
  return neighbours_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::location >*
tile::mutable_neighbours() {
  // @@protoc_insertion_point(field_mutable_list:mud.tile.neighbours)
  return &neighbours_;
}
inline const ::mud::location& tile::_internal_neighbours(int index) const {
  return neighbours_.Get(index);
}
inline const ::mud::location& tile::neighbours(int index) const {
  // @@protoc_insertion_point(field_get:mud.tile.neighbours)
  return _internal_neighbours(index);
}
inline ::mud::location* tile::_internal_add_neighbours() {
  return neighbours_.Add();
}
inline ::mud::location* tile::add_neighbours() {
  // @@protoc_insertion_point(field_add:mud.tile.neighbours)
  return _internal_add_neighbours();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::location >&
tile::neighbours() const {
  // @@protoc_insertion_point(field_list:mud.tile.neighbours)
  return neighbours_;
}

// -------------------------------------------------------------------

// player_book

// repeated .mud.player players = 1;
inline int player_book::_internal_players_size() const {
  return players_.size();
}
inline int player_book::players_size() const {
  return _internal_players_size();
}
inline void player_book::clear_players() {
  players_.Clear();
}
inline ::mud::player* player_book::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:mud.player_book.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >*
player_book::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:mud.player_book.players)
  return &players_;
}
inline const ::mud::player& player_book::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::mud::player& player_book::players(int index) const {
  // @@protoc_insertion_point(field_get:mud.player_book.players)
  return _internal_players(index);
}
inline ::mud::player* player_book::_internal_add_players() {
  return players_.Add();
}
inline ::mud::player* player_book::add_players() {
  // @@protoc_insertion_point(field_add:mud.player_book.players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::player >&
player_book::players() const {
  // @@protoc_insertion_point(field_list:mud.player_book.players)
  return players_;
}

// -------------------------------------------------------------------

// tile_book

// repeated .mud.tile tiles = 1;
inline int tile_book::_internal_tiles_size() const {
  return tiles_.size();
}
inline int tile_book::tiles_size() const {
  return _internal_tiles_size();
}
inline void tile_book::clear_tiles() {
  tiles_.Clear();
}
inline ::mud::tile* tile_book::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:mud.tile_book.tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >*
tile_book::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:mud.tile_book.tiles)
  return &tiles_;
}
inline const ::mud::tile& tile_book::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::mud::tile& tile_book::tiles(int index) const {
  // @@protoc_insertion_point(field_get:mud.tile_book.tiles)
  return _internal_tiles(index);
}
inline ::mud::tile* tile_book::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::mud::tile* tile_book::add_tiles() {
  // @@protoc_insertion_point(field_add:mud.tile_book.tiles)
  return _internal_add_tiles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >&
tile_book::tiles() const {
  // @@protoc_insertion_point(field_list:mud.tile_book.tiles)
  return tiles_;
}

// -------------------------------------------------------------------

// character_book

// repeated .mud.character characters = 1;
inline int character_book::_internal_characters_size() const {
  return characters_.size();
}
inline int character_book::characters_size() const {
  return _internal_characters_size();
}
inline void character_book::clear_characters() {
  characters_.Clear();
}
inline ::mud::character* character_book::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:mud.character_book.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
character_book::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:mud.character_book.characters)
  return &characters_;
}
inline const ::mud::character& character_book::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::mud::character& character_book::characters(int index) const {
  // @@protoc_insertion_point(field_get:mud.character_book.characters)
  return _internal_characters(index);
}
inline ::mud::character* character_book::_internal_add_characters() {
  return characters_.Add();
}
inline ::mud::character* character_book::add_characters() {
  // @@protoc_insertion_point(field_add:mud.character_book.characters)
  return _internal_add_characters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
character_book::characters() const {
  // @@protoc_insertion_point(field_list:mud.character_book.characters)
  return characters_;
}

// -------------------------------------------------------------------

// enemy_book

// repeated .mud.enemy enemies = 1;
inline int enemy_book::_internal_enemies_size() const {
  return enemies_.size();
}
inline int enemy_book::enemies_size() const {
  return _internal_enemies_size();
}
inline void enemy_book::clear_enemies() {
  enemies_.Clear();
}
inline ::mud::enemy* enemy_book::mutable_enemies(int index) {
  // @@protoc_insertion_point(field_mutable:mud.enemy_book.enemies)
  return enemies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >*
enemy_book::mutable_enemies() {
  // @@protoc_insertion_point(field_mutable_list:mud.enemy_book.enemies)
  return &enemies_;
}
inline const ::mud::enemy& enemy_book::_internal_enemies(int index) const {
  return enemies_.Get(index);
}
inline const ::mud::enemy& enemy_book::enemies(int index) const {
  // @@protoc_insertion_point(field_get:mud.enemy_book.enemies)
  return _internal_enemies(index);
}
inline ::mud::enemy* enemy_book::_internal_add_enemies() {
  return enemies_.Add();
}
inline ::mud::enemy* enemy_book::add_enemies() {
  // @@protoc_insertion_point(field_add:mud.enemy_book.enemies)
  return _internal_add_enemies();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >&
enemy_book::enemies() const {
  // @@protoc_insertion_point(field_list:mud.enemy_book.enemies)
  return enemies_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mud

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mud::direction_direction_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::direction_direction_enum>() {
  return ::mud::direction_direction_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::attribute_attribute_name_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::attribute_attribute_name_enum>() {
  return ::mud::attribute_attribute_name_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::character_character_state_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::character_character_state_enum>() {
  return ::mud::character_character_state_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::tile_tile_type_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::tile_tile_type_enum>() {
  return ::mud::tile_tile_type_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::tile_resident_type_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::tile_resident_type_enum>() {
  return ::mud::tile_resident_type_enum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mud_5flib_2eproto
