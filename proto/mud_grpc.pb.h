// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mud_grpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mud_5fgrpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mud_5fgrpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "mud_lib.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mud_5fgrpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_mud_5fgrpc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_mud_5fgrpc_2eproto;
namespace mud {
class create_character_in;
class create_character_inDefaultTypeInternal;
extern create_character_inDefaultTypeInternal _create_character_in_default_instance_;
class create_character_out;
class create_character_outDefaultTypeInternal;
extern create_character_outDefaultTypeInternal _create_character_out_default_instance_;
class get_token_in;
class get_token_inDefaultTypeInternal;
extern get_token_inDefaultTypeInternal _get_token_in_default_instance_;
class get_token_out;
class get_token_outDefaultTypeInternal;
extern get_token_outDefaultTypeInternal _get_token_out_default_instance_;
class login_in;
class login_inDefaultTypeInternal;
extern login_inDefaultTypeInternal _login_in_default_instance_;
class login_out;
class login_outDefaultTypeInternal;
extern login_outDefaultTypeInternal _login_out_default_instance_;
class play_in;
class play_inDefaultTypeInternal;
extern play_inDefaultTypeInternal _play_in_default_instance_;
class play_out;
class play_outDefaultTypeInternal;
extern play_outDefaultTypeInternal _play_out_default_instance_;
class select_character_in;
class select_character_inDefaultTypeInternal;
extern select_character_inDefaultTypeInternal _select_character_in_default_instance_;
class select_character_out;
class select_character_outDefaultTypeInternal;
extern select_character_outDefaultTypeInternal _select_character_out_default_instance_;
}  // namespace mud
PROTOBUF_NAMESPACE_OPEN
template<> ::mud::create_character_in* Arena::CreateMaybeMessage<::mud::create_character_in>(Arena*);
template<> ::mud::create_character_out* Arena::CreateMaybeMessage<::mud::create_character_out>(Arena*);
template<> ::mud::get_token_in* Arena::CreateMaybeMessage<::mud::get_token_in>(Arena*);
template<> ::mud::get_token_out* Arena::CreateMaybeMessage<::mud::get_token_out>(Arena*);
template<> ::mud::login_in* Arena::CreateMaybeMessage<::mud::login_in>(Arena*);
template<> ::mud::login_out* Arena::CreateMaybeMessage<::mud::login_out>(Arena*);
template<> ::mud::play_in* Arena::CreateMaybeMessage<::mud::play_in>(Arena*);
template<> ::mud::play_out* Arena::CreateMaybeMessage<::mud::play_out>(Arena*);
template<> ::mud::select_character_in* Arena::CreateMaybeMessage<::mud::select_character_in>(Arena*);
template<> ::mud::select_character_out* Arena::CreateMaybeMessage<::mud::select_character_out>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mud {

enum login_out_status_enum : int {
  login_out_status_enum_FAILURE = 0,
  login_out_status_enum_UNKNOWN_TOKEN = 1,
  login_out_status_enum_TOO_OLD_TOKEN = 2,
  login_out_status_enum_ALREADY_CONNECTED = 3,
  login_out_status_enum_SUCCESS = 4,
  login_out_status_enum_login_out_status_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  login_out_status_enum_login_out_status_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool login_out_status_enum_IsValid(int value);
constexpr login_out_status_enum login_out_status_enum_status_enum_MIN = login_out_status_enum_FAILURE;
constexpr login_out_status_enum login_out_status_enum_status_enum_MAX = login_out_status_enum_SUCCESS;
constexpr int login_out_status_enum_status_enum_ARRAYSIZE = login_out_status_enum_status_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* login_out_status_enum_descriptor();
template<typename T>
inline const std::string& login_out_status_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, login_out_status_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function login_out_status_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    login_out_status_enum_descriptor(), enum_t_value);
}
inline bool login_out_status_enum_Parse(
    const std::string& name, login_out_status_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<login_out_status_enum>(
    login_out_status_enum_descriptor(), name, value);
}
enum select_character_out_status_enum : int {
  select_character_out_status_enum_FAILURE = 0,
  select_character_out_status_enum_FORBIDDEN = 1,
  select_character_out_status_enum_SUCCESS = 2,
  select_character_out_status_enum_select_character_out_status_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  select_character_out_status_enum_select_character_out_status_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool select_character_out_status_enum_IsValid(int value);
constexpr select_character_out_status_enum select_character_out_status_enum_status_enum_MIN = select_character_out_status_enum_FAILURE;
constexpr select_character_out_status_enum select_character_out_status_enum_status_enum_MAX = select_character_out_status_enum_SUCCESS;
constexpr int select_character_out_status_enum_status_enum_ARRAYSIZE = select_character_out_status_enum_status_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* select_character_out_status_enum_descriptor();
template<typename T>
inline const std::string& select_character_out_status_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, select_character_out_status_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function select_character_out_status_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    select_character_out_status_enum_descriptor(), enum_t_value);
}
inline bool select_character_out_status_enum_Parse(
    const std::string& name, select_character_out_status_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<select_character_out_status_enum>(
    select_character_out_status_enum_descriptor(), name, value);
}
enum create_character_out_status_enum : int {
  create_character_out_status_enum_FAILURE = 0,
  create_character_out_status_enum_ALREADY_IN = 1,
  create_character_out_status_enum_SUCCESS = 2,
  create_character_out_status_enum_create_character_out_status_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  create_character_out_status_enum_create_character_out_status_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool create_character_out_status_enum_IsValid(int value);
constexpr create_character_out_status_enum create_character_out_status_enum_status_enum_MIN = create_character_out_status_enum_FAILURE;
constexpr create_character_out_status_enum create_character_out_status_enum_status_enum_MAX = create_character_out_status_enum_SUCCESS;
constexpr int create_character_out_status_enum_status_enum_ARRAYSIZE = create_character_out_status_enum_status_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* create_character_out_status_enum_descriptor();
template<typename T>
inline const std::string& create_character_out_status_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, create_character_out_status_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function create_character_out_status_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    create_character_out_status_enum_descriptor(), enum_t_value);
}
inline bool create_character_out_status_enum_Parse(
    const std::string& name, create_character_out_status_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<create_character_out_status_enum>(
    create_character_out_status_enum_descriptor(), name, value);
}
enum play_in_command_enum : int {
  play_in_command_enum_NO_COMMAND = 0,
  play_in_command_enum_TURN_LEFT = 1,
  play_in_command_enum_TURN_RIGHT = 2,
  play_in_command_enum_FORWARD = 3,
  play_in_command_enum_BACKWARD = 4,
  play_in_command_enum_ATTACK_MELEE = 5,
  play_in_command_enum_ATTACK_RANGE = 6,
  play_in_command_enum_DEFEND = 7,
  play_in_command_enum_HEAL = 8,
  play_in_command_enum_INFO = 9,
  play_in_command_enum_QUIT = 10,
  play_in_command_enum_play_in_command_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  play_in_command_enum_play_in_command_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool play_in_command_enum_IsValid(int value);
constexpr play_in_command_enum play_in_command_enum_command_enum_MIN = play_in_command_enum_NO_COMMAND;
constexpr play_in_command_enum play_in_command_enum_command_enum_MAX = play_in_command_enum_QUIT;
constexpr int play_in_command_enum_command_enum_ARRAYSIZE = play_in_command_enum_command_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* play_in_command_enum_descriptor();
template<typename T>
inline const std::string& play_in_command_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, play_in_command_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function play_in_command_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    play_in_command_enum_descriptor(), enum_t_value);
}
inline bool play_in_command_enum_Parse(
    const std::string& name, play_in_command_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<play_in_command_enum>(
    play_in_command_enum_descriptor(), name, value);
}
enum play_out_status_enum : int {
  play_out_status_enum_FAILURE = 0,
  play_out_status_enum_SUCCESS = 1,
  play_out_status_enum_QUIT = 2,
  play_out_status_enum_DEAD = 3,
  play_out_status_enum_play_out_status_enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  play_out_status_enum_play_out_status_enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool play_out_status_enum_IsValid(int value);
constexpr play_out_status_enum play_out_status_enum_status_enum_MIN = play_out_status_enum_FAILURE;
constexpr play_out_status_enum play_out_status_enum_status_enum_MAX = play_out_status_enum_DEAD;
constexpr int play_out_status_enum_status_enum_ARRAYSIZE = play_out_status_enum_status_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* play_out_status_enum_descriptor();
template<typename T>
inline const std::string& play_out_status_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, play_out_status_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function play_out_status_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    play_out_status_enum_descriptor(), enum_t_value);
}
inline bool play_out_status_enum_Parse(
    const std::string& name, play_out_status_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<play_out_status_enum>(
    play_out_status_enum_descriptor(), name, value);
}
// ===================================================================

class get_token_in :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.get_token_in) */ {
 public:
  get_token_in();
  virtual ~get_token_in();

  get_token_in(const get_token_in& from);
  get_token_in(get_token_in&& from) noexcept
    : get_token_in() {
    *this = ::std::move(from);
  }

  inline get_token_in& operator=(const get_token_in& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_token_in& operator=(get_token_in&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const get_token_in& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const get_token_in* internal_default_instance() {
    return reinterpret_cast<const get_token_in*>(
               &_get_token_in_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(get_token_in& a, get_token_in& b) {
    a.Swap(&b);
  }
  inline void Swap(get_token_in* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_token_in* New() const final {
    return CreateMaybeMessage<get_token_in>(nullptr);
  }

  get_token_in* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_token_in>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const get_token_in& from);
  void MergeFrom(const get_token_in& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_token_in* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.get_token_in";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5fgrpc_2eproto);
    return ::descriptor_table_mud_5fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mud.get_token_in)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class get_token_out :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.get_token_out) */ {
 public:
  get_token_out();
  virtual ~get_token_out();

  get_token_out(const get_token_out& from);
  get_token_out(get_token_out&& from) noexcept
    : get_token_out() {
    *this = ::std::move(from);
  }

  inline get_token_out& operator=(const get_token_out& from) {
    CopyFrom(from);
    return *this;
  }
  inline get_token_out& operator=(get_token_out&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const get_token_out& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const get_token_out* internal_default_instance() {
    return reinterpret_cast<const get_token_out*>(
               &_get_token_out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(get_token_out& a, get_token_out& b) {
    a.Swap(&b);
  }
  inline void Swap(get_token_out* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline get_token_out* New() const final {
    return CreateMaybeMessage<get_token_out>(nullptr);
  }

  get_token_out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<get_token_out>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const get_token_out& from);
  void MergeFrom(const get_token_out& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(get_token_out* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.get_token_out";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5fgrpc_2eproto);
    return ::descriptor_table_mud_5fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdTokenFieldNumber = 1,
  };
  // int64 id_token = 1;
  void clear_id_token();
  ::PROTOBUF_NAMESPACE_ID::int64 id_token() const;
  void set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_token() const;
  void _internal_set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.get_token_out)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class login_in :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.login_in) */ {
 public:
  login_in();
  virtual ~login_in();

  login_in(const login_in& from);
  login_in(login_in&& from) noexcept
    : login_in() {
    *this = ::std::move(from);
  }

  inline login_in& operator=(const login_in& from) {
    CopyFrom(from);
    return *this;
  }
  inline login_in& operator=(login_in&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const login_in& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const login_in* internal_default_instance() {
    return reinterpret_cast<const login_in*>(
               &_login_in_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(login_in& a, login_in& b) {
    a.Swap(&b);
  }
  inline void Swap(login_in* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline login_in* New() const final {
    return CreateMaybeMessage<login_in>(nullptr);
  }

  login_in* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<login_in>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const login_in& from);
  void MergeFrom(const login_in& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(login_in* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.login_in";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5fgrpc_2eproto);
    return ::descriptor_table_mud_5fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswordHashFieldNumber = 2,
    kIdTokenFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string password_hash = 2;
  void clear_password_hash();
  const std::string& password_hash() const;
  void set_password_hash(const std::string& value);
  void set_password_hash(std::string&& value);
  void set_password_hash(const char* value);
  void set_password_hash(const char* value, size_t size);
  std::string* mutable_password_hash();
  std::string* release_password_hash();
  void set_allocated_password_hash(std::string* password_hash);
  private:
  const std::string& _internal_password_hash() const;
  void _internal_set_password_hash(const std::string& value);
  std::string* _internal_mutable_password_hash();
  public:

  // int64 id_token = 3;
  void clear_id_token();
  ::PROTOBUF_NAMESPACE_ID::int64 id_token() const;
  void set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_token() const;
  void _internal_set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.login_in)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_hash_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class login_out :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.login_out) */ {
 public:
  login_out();
  virtual ~login_out();

  login_out(const login_out& from);
  login_out(login_out&& from) noexcept
    : login_out() {
    *this = ::std::move(from);
  }

  inline login_out& operator=(const login_out& from) {
    CopyFrom(from);
    return *this;
  }
  inline login_out& operator=(login_out&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const login_out& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const login_out* internal_default_instance() {
    return reinterpret_cast<const login_out*>(
               &_login_out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(login_out& a, login_out& b) {
    a.Swap(&b);
  }
  inline void Swap(login_out* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline login_out* New() const final {
    return CreateMaybeMessage<login_out>(nullptr);
  }

  login_out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<login_out>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const login_out& from);
  void MergeFrom(const login_out& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(login_out* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.login_out";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5fgrpc_2eproto);
    return ::descriptor_table_mud_5fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef login_out_status_enum status_enum;
  static constexpr status_enum FAILURE =
    login_out_status_enum_FAILURE;
  static constexpr status_enum UNKNOWN_TOKEN =
    login_out_status_enum_UNKNOWN_TOKEN;
  static constexpr status_enum TOO_OLD_TOKEN =
    login_out_status_enum_TOO_OLD_TOKEN;
  static constexpr status_enum ALREADY_CONNECTED =
    login_out_status_enum_ALREADY_CONNECTED;
  static constexpr status_enum SUCCESS =
    login_out_status_enum_SUCCESS;
  static inline bool status_enum_IsValid(int value) {
    return login_out_status_enum_IsValid(value);
  }
  static constexpr status_enum status_enum_MIN =
    login_out_status_enum_status_enum_MIN;
  static constexpr status_enum status_enum_MAX =
    login_out_status_enum_status_enum_MAX;
  static constexpr int status_enum_ARRAYSIZE =
    login_out_status_enum_status_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  status_enum_descriptor() {
    return login_out_status_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& status_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, status_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function status_enum_Name.");
    return login_out_status_enum_Name(enum_t_value);
  }
  static inline bool status_enum_Parse(const std::string& name,
      status_enum* value) {
    return login_out_status_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 2,
    kIdPlayerFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // repeated .mud.character characters = 2;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::mud::character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
      mutable_characters();
  private:
  const ::mud::character& _internal_characters(int index) const;
  ::mud::character* _internal_add_characters();
  public:
  const ::mud::character& characters(int index) const;
  ::mud::character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
      characters() const;

  // int64 id_player = 3;
  void clear_id_player();
  ::PROTOBUF_NAMESPACE_ID::int64 id_player() const;
  void set_id_player(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_player() const;
  void _internal_set_id_player(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.login_out.status_enum status = 1;
  void clear_status();
  ::mud::login_out_status_enum status() const;
  void set_status(::mud::login_out_status_enum value);
  private:
  ::mud::login_out_status_enum _internal_status() const;
  void _internal_set_status(::mud::login_out_status_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.login_out)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character > characters_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_player_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class select_character_in :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.select_character_in) */ {
 public:
  select_character_in();
  virtual ~select_character_in();

  select_character_in(const select_character_in& from);
  select_character_in(select_character_in&& from) noexcept
    : select_character_in() {
    *this = ::std::move(from);
  }

  inline select_character_in& operator=(const select_character_in& from) {
    CopyFrom(from);
    return *this;
  }
  inline select_character_in& operator=(select_character_in&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const select_character_in& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const select_character_in* internal_default_instance() {
    return reinterpret_cast<const select_character_in*>(
               &_select_character_in_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(select_character_in& a, select_character_in& b) {
    a.Swap(&b);
  }
  inline void Swap(select_character_in* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline select_character_in* New() const final {
    return CreateMaybeMessage<select_character_in>(nullptr);
  }

  select_character_in* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<select_character_in>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const select_character_in& from);
  void MergeFrom(const select_character_in& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(select_character_in* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.select_character_in";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5fgrpc_2eproto);
    return ::descriptor_table_mud_5fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdCharacterFieldNumber = 1,
    kIdTokenFieldNumber = 2,
  };
  // int64 id_character = 1;
  void clear_id_character();
  ::PROTOBUF_NAMESPACE_ID::int64 id_character() const;
  void set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_character() const;
  void _internal_set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 id_token = 2;
  void clear_id_token();
  ::PROTOBUF_NAMESPACE_ID::int64 id_token() const;
  void set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_token() const;
  void _internal_set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.select_character_in)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_character_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class select_character_out :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.select_character_out) */ {
 public:
  select_character_out();
  virtual ~select_character_out();

  select_character_out(const select_character_out& from);
  select_character_out(select_character_out&& from) noexcept
    : select_character_out() {
    *this = ::std::move(from);
  }

  inline select_character_out& operator=(const select_character_out& from) {
    CopyFrom(from);
    return *this;
  }
  inline select_character_out& operator=(select_character_out&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const select_character_out& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const select_character_out* internal_default_instance() {
    return reinterpret_cast<const select_character_out*>(
               &_select_character_out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(select_character_out& a, select_character_out& b) {
    a.Swap(&b);
  }
  inline void Swap(select_character_out* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline select_character_out* New() const final {
    return CreateMaybeMessage<select_character_out>(nullptr);
  }

  select_character_out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<select_character_out>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const select_character_out& from);
  void MergeFrom(const select_character_out& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(select_character_out* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.select_character_out";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5fgrpc_2eproto);
    return ::descriptor_table_mud_5fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef select_character_out_status_enum status_enum;
  static constexpr status_enum FAILURE =
    select_character_out_status_enum_FAILURE;
  static constexpr status_enum FORBIDDEN =
    select_character_out_status_enum_FORBIDDEN;
  static constexpr status_enum SUCCESS =
    select_character_out_status_enum_SUCCESS;
  static inline bool status_enum_IsValid(int value) {
    return select_character_out_status_enum_IsValid(value);
  }
  static constexpr status_enum status_enum_MIN =
    select_character_out_status_enum_status_enum_MIN;
  static constexpr status_enum status_enum_MAX =
    select_character_out_status_enum_status_enum_MAX;
  static constexpr int status_enum_ARRAYSIZE =
    select_character_out_status_enum_status_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  status_enum_descriptor() {
    return select_character_out_status_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& status_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, status_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function status_enum_Name.");
    return select_character_out_status_enum_Name(enum_t_value);
  }
  static inline bool status_enum_Parse(const std::string& name,
      status_enum* value) {
    return select_character_out_status_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // .mud.select_character_out.status_enum status = 1;
  void clear_status();
  ::mud::select_character_out_status_enum status() const;
  void set_status(::mud::select_character_out_status_enum value);
  private:
  ::mud::select_character_out_status_enum _internal_status() const;
  void _internal_set_status(::mud::select_character_out_status_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.select_character_out)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class create_character_in :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.create_character_in) */ {
 public:
  create_character_in();
  virtual ~create_character_in();

  create_character_in(const create_character_in& from);
  create_character_in(create_character_in&& from) noexcept
    : create_character_in() {
    *this = ::std::move(from);
  }

  inline create_character_in& operator=(const create_character_in& from) {
    CopyFrom(from);
    return *this;
  }
  inline create_character_in& operator=(create_character_in&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const create_character_in& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const create_character_in* internal_default_instance() {
    return reinterpret_cast<const create_character_in*>(
               &_create_character_in_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(create_character_in& a, create_character_in& b) {
    a.Swap(&b);
  }
  inline void Swap(create_character_in* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline create_character_in* New() const final {
    return CreateMaybeMessage<create_character_in>(nullptr);
  }

  create_character_in* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<create_character_in>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const create_character_in& from);
  void MergeFrom(const create_character_in& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(create_character_in* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.create_character_in";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5fgrpc_2eproto);
    return ::descriptor_table_mud_5fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kIdTokenFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // int64 id_token = 3;
  void clear_id_token();
  ::PROTOBUF_NAMESPACE_ID::int64 id_token() const;
  void set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_token() const;
  void _internal_set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:mud.create_character_in)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class create_character_out :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.create_character_out) */ {
 public:
  create_character_out();
  virtual ~create_character_out();

  create_character_out(const create_character_out& from);
  create_character_out(create_character_out&& from) noexcept
    : create_character_out() {
    *this = ::std::move(from);
  }

  inline create_character_out& operator=(const create_character_out& from) {
    CopyFrom(from);
    return *this;
  }
  inline create_character_out& operator=(create_character_out&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const create_character_out& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const create_character_out* internal_default_instance() {
    return reinterpret_cast<const create_character_out*>(
               &_create_character_out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(create_character_out& a, create_character_out& b) {
    a.Swap(&b);
  }
  inline void Swap(create_character_out* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline create_character_out* New() const final {
    return CreateMaybeMessage<create_character_out>(nullptr);
  }

  create_character_out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<create_character_out>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const create_character_out& from);
  void MergeFrom(const create_character_out& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(create_character_out* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.create_character_out";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5fgrpc_2eproto);
    return ::descriptor_table_mud_5fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef create_character_out_status_enum status_enum;
  static constexpr status_enum FAILURE =
    create_character_out_status_enum_FAILURE;
  static constexpr status_enum ALREADY_IN =
    create_character_out_status_enum_ALREADY_IN;
  static constexpr status_enum SUCCESS =
    create_character_out_status_enum_SUCCESS;
  static inline bool status_enum_IsValid(int value) {
    return create_character_out_status_enum_IsValid(value);
  }
  static constexpr status_enum status_enum_MIN =
    create_character_out_status_enum_status_enum_MIN;
  static constexpr status_enum status_enum_MAX =
    create_character_out_status_enum_status_enum_MAX;
  static constexpr int status_enum_ARRAYSIZE =
    create_character_out_status_enum_status_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  status_enum_descriptor() {
    return create_character_out_status_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& status_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, status_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function status_enum_Name.");
    return create_character_out_status_enum_Name(enum_t_value);
  }
  static inline bool status_enum_Parse(const std::string& name,
      status_enum* value) {
    return create_character_out_status_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCharactersFieldNumber = 3,
    kIdCharacterFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated .mud.character characters = 3;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::mud::character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
      mutable_characters();
  private:
  const ::mud::character& _internal_characters(int index) const;
  ::mud::character* _internal_add_characters();
  public:
  const ::mud::character& characters(int index) const;
  ::mud::character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
      characters() const;

  // int64 id_character = 2;
  void clear_id_character();
  ::PROTOBUF_NAMESPACE_ID::int64 id_character() const;
  void set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_character() const;
  void _internal_set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.create_character_out.status_enum status = 1;
  void clear_status();
  ::mud::create_character_out_status_enum status() const;
  void set_status(::mud::create_character_out_status_enum value);
  private:
  ::mud::create_character_out_status_enum _internal_status() const;
  void _internal_set_status(::mud::create_character_out_status_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.create_character_out)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character > characters_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_character_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class play_in :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.play_in) */ {
 public:
  play_in();
  virtual ~play_in();

  play_in(const play_in& from);
  play_in(play_in&& from) noexcept
    : play_in() {
    *this = ::std::move(from);
  }

  inline play_in& operator=(const play_in& from) {
    CopyFrom(from);
    return *this;
  }
  inline play_in& operator=(play_in&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const play_in& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const play_in* internal_default_instance() {
    return reinterpret_cast<const play_in*>(
               &_play_in_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(play_in& a, play_in& b) {
    a.Swap(&b);
  }
  inline void Swap(play_in* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline play_in* New() const final {
    return CreateMaybeMessage<play_in>(nullptr);
  }

  play_in* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<play_in>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const play_in& from);
  void MergeFrom(const play_in& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(play_in* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.play_in";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5fgrpc_2eproto);
    return ::descriptor_table_mud_5fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef play_in_command_enum command_enum;
  static constexpr command_enum NO_COMMAND =
    play_in_command_enum_NO_COMMAND;
  static constexpr command_enum TURN_LEFT =
    play_in_command_enum_TURN_LEFT;
  static constexpr command_enum TURN_RIGHT =
    play_in_command_enum_TURN_RIGHT;
  static constexpr command_enum FORWARD =
    play_in_command_enum_FORWARD;
  static constexpr command_enum BACKWARD =
    play_in_command_enum_BACKWARD;
  static constexpr command_enum ATTACK_MELEE =
    play_in_command_enum_ATTACK_MELEE;
  static constexpr command_enum ATTACK_RANGE =
    play_in_command_enum_ATTACK_RANGE;
  static constexpr command_enum DEFEND =
    play_in_command_enum_DEFEND;
  static constexpr command_enum HEAL =
    play_in_command_enum_HEAL;
  static constexpr command_enum INFO =
    play_in_command_enum_INFO;
  static constexpr command_enum QUIT =
    play_in_command_enum_QUIT;
  static inline bool command_enum_IsValid(int value) {
    return play_in_command_enum_IsValid(value);
  }
  static constexpr command_enum command_enum_MIN =
    play_in_command_enum_command_enum_MIN;
  static constexpr command_enum command_enum_MAX =
    play_in_command_enum_command_enum_MAX;
  static constexpr int command_enum_ARRAYSIZE =
    play_in_command_enum_command_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  command_enum_descriptor() {
    return play_in_command_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& command_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, command_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function command_enum_Name.");
    return play_in_command_enum_Name(enum_t_value);
  }
  static inline bool command_enum_Parse(const std::string& name,
      command_enum* value) {
    return play_in_command_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdTokenFieldNumber = 1,
    kIdPlayerFieldNumber = 2,
    kIdCharacterFieldNumber = 3,
    kCommandFieldNumber = 4,
  };
  // int64 id_token = 1;
  void clear_id_token();
  ::PROTOBUF_NAMESPACE_ID::int64 id_token() const;
  void set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_token() const;
  void _internal_set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 id_player = 2;
  void clear_id_player();
  ::PROTOBUF_NAMESPACE_ID::int64 id_player() const;
  void set_id_player(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_player() const;
  void _internal_set_id_player(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 id_character = 3;
  void clear_id_character();
  ::PROTOBUF_NAMESPACE_ID::int64 id_character() const;
  void set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_character() const;
  void _internal_set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.play_in.command_enum command = 4;
  void clear_command();
  ::mud::play_in_command_enum command() const;
  void set_command(::mud::play_in_command_enum value);
  private:
  ::mud::play_in_command_enum _internal_command() const;
  void _internal_set_command(::mud::play_in_command_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.play_in)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_token_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_player_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_character_;
  int command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class play_out :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:mud.play_out) */ {
 public:
  play_out();
  virtual ~play_out();

  play_out(const play_out& from);
  play_out(play_out&& from) noexcept
    : play_out() {
    *this = ::std::move(from);
  }

  inline play_out& operator=(const play_out& from) {
    CopyFrom(from);
    return *this;
  }
  inline play_out& operator=(play_out&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const play_out& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const play_out* internal_default_instance() {
    return reinterpret_cast<const play_out*>(
               &_play_out_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(play_out& a, play_out& b) {
    a.Swap(&b);
  }
  inline void Swap(play_out* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline play_out* New() const final {
    return CreateMaybeMessage<play_out>(nullptr);
  }

  play_out* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<play_out>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const play_out& from);
  void MergeFrom(const play_out& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(play_out* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "mud.play_out";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_mud_5fgrpc_2eproto);
    return ::descriptor_table_mud_5fgrpc_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef play_out_status_enum status_enum;
  static constexpr status_enum FAILURE =
    play_out_status_enum_FAILURE;
  static constexpr status_enum SUCCESS =
    play_out_status_enum_SUCCESS;
  static constexpr status_enum QUIT =
    play_out_status_enum_QUIT;
  static constexpr status_enum DEAD =
    play_out_status_enum_DEAD;
  static inline bool status_enum_IsValid(int value) {
    return play_out_status_enum_IsValid(value);
  }
  static constexpr status_enum status_enum_MIN =
    play_out_status_enum_status_enum_MIN;
  static constexpr status_enum status_enum_MAX =
    play_out_status_enum_status_enum_MAX;
  static constexpr int status_enum_ARRAYSIZE =
    play_out_status_enum_status_enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  status_enum_descriptor() {
    return play_out_status_enum_descriptor();
  }
  template<typename T>
  static inline const std::string& status_enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, status_enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function status_enum_Name.");
    return play_out_status_enum_Name(enum_t_value);
  }
  static inline bool status_enum_Parse(const std::string& name,
      status_enum* value) {
    return play_out_status_enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTilesFieldNumber = 3,
    kCharactersFieldNumber = 4,
    kEnemiesFieldNumber = 5,
    kItemsFieldNumber = 6,
    kIdCharacterFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // repeated .mud.tile tiles = 3;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::mud::tile* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >*
      mutable_tiles();
  private:
  const ::mud::tile& _internal_tiles(int index) const;
  ::mud::tile* _internal_add_tiles();
  public:
  const ::mud::tile& tiles(int index) const;
  ::mud::tile* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >&
      tiles() const;

  // repeated .mud.character characters = 4;
  int characters_size() const;
  private:
  int _internal_characters_size() const;
  public:
  void clear_characters();
  ::mud::character* mutable_characters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
      mutable_characters();
  private:
  const ::mud::character& _internal_characters(int index) const;
  ::mud::character* _internal_add_characters();
  public:
  const ::mud::character& characters(int index) const;
  ::mud::character* add_characters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
      characters() const;

  // repeated .mud.enemy enemies = 5;
  int enemies_size() const;
  private:
  int _internal_enemies_size() const;
  public:
  void clear_enemies();
  ::mud::enemy* mutable_enemies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >*
      mutable_enemies();
  private:
  const ::mud::enemy& _internal_enemies(int index) const;
  ::mud::enemy* _internal_add_enemies();
  public:
  const ::mud::enemy& enemies(int index) const;
  ::mud::enemy* add_enemies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >&
      enemies() const;

  // repeated .mud.item items = 6;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::mud::item* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::item >*
      mutable_items();
  private:
  const ::mud::item& _internal_items(int index) const;
  ::mud::item* _internal_add_items();
  public:
  const ::mud::item& items(int index) const;
  ::mud::item* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::item >&
      items() const;

  // int64 id_character = 1;
  void clear_id_character();
  ::PROTOBUF_NAMESPACE_ID::int64 id_character() const;
  void set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id_character() const;
  void _internal_set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .mud.play_out.status_enum status = 2;
  void clear_status();
  ::mud::play_out_status_enum status() const;
  void set_status(::mud::play_out_status_enum value);
  private:
  ::mud::play_out_status_enum _internal_status() const;
  void _internal_set_status(::mud::play_out_status_enum value);
  public:

  // @@protoc_insertion_point(class_scope:mud.play_out)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile > tiles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character > characters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy > enemies_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::item > items_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_character_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_mud_5fgrpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// get_token_in

// -------------------------------------------------------------------

// get_token_out

// int64 id_token = 1;
inline void get_token_out::clear_id_token() {
  id_token_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 get_token_out::_internal_id_token() const {
  return id_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 get_token_out::id_token() const {
  // @@protoc_insertion_point(field_get:mud.get_token_out.id_token)
  return _internal_id_token();
}
inline void get_token_out::_internal_set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_token_ = value;
}
inline void get_token_out::set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_token(value);
  // @@protoc_insertion_point(field_set:mud.get_token_out.id_token)
}

// -------------------------------------------------------------------

// login_in

// string name = 1;
inline void login_in::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& login_in::name() const {
  // @@protoc_insertion_point(field_get:mud.login_in.name)
  return _internal_name();
}
inline void login_in::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.login_in.name)
}
inline std::string* login_in::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.login_in.name)
  return _internal_mutable_name();
}
inline const std::string& login_in::_internal_name() const {
  return name_.GetNoArena();
}
inline void login_in::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void login_in::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.login_in.name)
}
inline void login_in::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.login_in.name)
}
inline void login_in::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.login_in.name)
}
inline std::string* login_in::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* login_in::release_name() {
  // @@protoc_insertion_point(field_release:mud.login_in.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void login_in::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.login_in.name)
}

// string password_hash = 2;
inline void login_in::clear_password_hash() {
  password_hash_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& login_in::password_hash() const {
  // @@protoc_insertion_point(field_get:mud.login_in.password_hash)
  return _internal_password_hash();
}
inline void login_in::set_password_hash(const std::string& value) {
  _internal_set_password_hash(value);
  // @@protoc_insertion_point(field_set:mud.login_in.password_hash)
}
inline std::string* login_in::mutable_password_hash() {
  // @@protoc_insertion_point(field_mutable:mud.login_in.password_hash)
  return _internal_mutable_password_hash();
}
inline const std::string& login_in::_internal_password_hash() const {
  return password_hash_.GetNoArena();
}
inline void login_in::_internal_set_password_hash(const std::string& value) {
  
  password_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void login_in::set_password_hash(std::string&& value) {
  
  password_hash_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.login_in.password_hash)
}
inline void login_in::set_password_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.login_in.password_hash)
}
inline void login_in::set_password_hash(const char* value, size_t size) {
  
  password_hash_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.login_in.password_hash)
}
inline std::string* login_in::_internal_mutable_password_hash() {
  
  return password_hash_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* login_in::release_password_hash() {
  // @@protoc_insertion_point(field_release:mud.login_in.password_hash)
  
  return password_hash_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void login_in::set_allocated_password_hash(std::string* password_hash) {
  if (password_hash != nullptr) {
    
  } else {
    
  }
  password_hash_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password_hash);
  // @@protoc_insertion_point(field_set_allocated:mud.login_in.password_hash)
}

// int64 id_token = 3;
inline void login_in::clear_id_token() {
  id_token_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 login_in::_internal_id_token() const {
  return id_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 login_in::id_token() const {
  // @@protoc_insertion_point(field_get:mud.login_in.id_token)
  return _internal_id_token();
}
inline void login_in::_internal_set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_token_ = value;
}
inline void login_in::set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_token(value);
  // @@protoc_insertion_point(field_set:mud.login_in.id_token)
}

// -------------------------------------------------------------------

// login_out

// .mud.login_out.status_enum status = 1;
inline void login_out::clear_status() {
  status_ = 0;
}
inline ::mud::login_out_status_enum login_out::_internal_status() const {
  return static_cast< ::mud::login_out_status_enum >(status_);
}
inline ::mud::login_out_status_enum login_out::status() const {
  // @@protoc_insertion_point(field_get:mud.login_out.status)
  return _internal_status();
}
inline void login_out::_internal_set_status(::mud::login_out_status_enum value) {
  
  status_ = value;
}
inline void login_out::set_status(::mud::login_out_status_enum value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mud.login_out.status)
}

// int64 id_player = 3;
inline void login_out::clear_id_player() {
  id_player_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 login_out::_internal_id_player() const {
  return id_player_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 login_out::id_player() const {
  // @@protoc_insertion_point(field_get:mud.login_out.id_player)
  return _internal_id_player();
}
inline void login_out::_internal_set_id_player(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_player_ = value;
}
inline void login_out::set_id_player(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_player(value);
  // @@protoc_insertion_point(field_set:mud.login_out.id_player)
}

// repeated .mud.character characters = 2;
inline int login_out::_internal_characters_size() const {
  return characters_.size();
}
inline int login_out::characters_size() const {
  return _internal_characters_size();
}
inline ::mud::character* login_out::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:mud.login_out.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
login_out::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:mud.login_out.characters)
  return &characters_;
}
inline const ::mud::character& login_out::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::mud::character& login_out::characters(int index) const {
  // @@protoc_insertion_point(field_get:mud.login_out.characters)
  return _internal_characters(index);
}
inline ::mud::character* login_out::_internal_add_characters() {
  return characters_.Add();
}
inline ::mud::character* login_out::add_characters() {
  // @@protoc_insertion_point(field_add:mud.login_out.characters)
  return _internal_add_characters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
login_out::characters() const {
  // @@protoc_insertion_point(field_list:mud.login_out.characters)
  return characters_;
}

// -------------------------------------------------------------------

// select_character_in

// int64 id_character = 1;
inline void select_character_in::clear_id_character() {
  id_character_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 select_character_in::_internal_id_character() const {
  return id_character_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 select_character_in::id_character() const {
  // @@protoc_insertion_point(field_get:mud.select_character_in.id_character)
  return _internal_id_character();
}
inline void select_character_in::_internal_set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_character_ = value;
}
inline void select_character_in::set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_character(value);
  // @@protoc_insertion_point(field_set:mud.select_character_in.id_character)
}

// int64 id_token = 2;
inline void select_character_in::clear_id_token() {
  id_token_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 select_character_in::_internal_id_token() const {
  return id_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 select_character_in::id_token() const {
  // @@protoc_insertion_point(field_get:mud.select_character_in.id_token)
  return _internal_id_token();
}
inline void select_character_in::_internal_set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_token_ = value;
}
inline void select_character_in::set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_token(value);
  // @@protoc_insertion_point(field_set:mud.select_character_in.id_token)
}

// -------------------------------------------------------------------

// select_character_out

// .mud.select_character_out.status_enum status = 1;
inline void select_character_out::clear_status() {
  status_ = 0;
}
inline ::mud::select_character_out_status_enum select_character_out::_internal_status() const {
  return static_cast< ::mud::select_character_out_status_enum >(status_);
}
inline ::mud::select_character_out_status_enum select_character_out::status() const {
  // @@protoc_insertion_point(field_get:mud.select_character_out.status)
  return _internal_status();
}
inline void select_character_out::_internal_set_status(::mud::select_character_out_status_enum value) {
  
  status_ = value;
}
inline void select_character_out::set_status(::mud::select_character_out_status_enum value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mud.select_character_out.status)
}

// -------------------------------------------------------------------

// create_character_in

// string name = 1;
inline void create_character_in::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& create_character_in::name() const {
  // @@protoc_insertion_point(field_get:mud.create_character_in.name)
  return _internal_name();
}
inline void create_character_in::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:mud.create_character_in.name)
}
inline std::string* create_character_in::mutable_name() {
  // @@protoc_insertion_point(field_mutable:mud.create_character_in.name)
  return _internal_mutable_name();
}
inline const std::string& create_character_in::_internal_name() const {
  return name_.GetNoArena();
}
inline void create_character_in::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void create_character_in::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.create_character_in.name)
}
inline void create_character_in::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.create_character_in.name)
}
inline void create_character_in::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.create_character_in.name)
}
inline std::string* create_character_in::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* create_character_in::release_name() {
  // @@protoc_insertion_point(field_release:mud.create_character_in.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void create_character_in::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mud.create_character_in.name)
}

// string description = 2;
inline void create_character_in::clear_description() {
  description_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& create_character_in::description() const {
  // @@protoc_insertion_point(field_get:mud.create_character_in.description)
  return _internal_description();
}
inline void create_character_in::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:mud.create_character_in.description)
}
inline std::string* create_character_in::mutable_description() {
  // @@protoc_insertion_point(field_mutable:mud.create_character_in.description)
  return _internal_mutable_description();
}
inline const std::string& create_character_in::_internal_description() const {
  return description_.GetNoArena();
}
inline void create_character_in::_internal_set_description(const std::string& value) {
  
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void create_character_in::set_description(std::string&& value) {
  
  description_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mud.create_character_in.description)
}
inline void create_character_in::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mud.create_character_in.description)
}
inline void create_character_in::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mud.create_character_in.description)
}
inline std::string* create_character_in::_internal_mutable_description() {
  
  return description_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* create_character_in::release_description() {
  // @@protoc_insertion_point(field_release:mud.create_character_in.description)
  
  return description_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void create_character_in::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:mud.create_character_in.description)
}

// int64 id_token = 3;
inline void create_character_in::clear_id_token() {
  id_token_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 create_character_in::_internal_id_token() const {
  return id_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 create_character_in::id_token() const {
  // @@protoc_insertion_point(field_get:mud.create_character_in.id_token)
  return _internal_id_token();
}
inline void create_character_in::_internal_set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_token_ = value;
}
inline void create_character_in::set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_token(value);
  // @@protoc_insertion_point(field_set:mud.create_character_in.id_token)
}

// -------------------------------------------------------------------

// create_character_out

// .mud.create_character_out.status_enum status = 1;
inline void create_character_out::clear_status() {
  status_ = 0;
}
inline ::mud::create_character_out_status_enum create_character_out::_internal_status() const {
  return static_cast< ::mud::create_character_out_status_enum >(status_);
}
inline ::mud::create_character_out_status_enum create_character_out::status() const {
  // @@protoc_insertion_point(field_get:mud.create_character_out.status)
  return _internal_status();
}
inline void create_character_out::_internal_set_status(::mud::create_character_out_status_enum value) {
  
  status_ = value;
}
inline void create_character_out::set_status(::mud::create_character_out_status_enum value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mud.create_character_out.status)
}

// int64 id_character = 2;
inline void create_character_out::clear_id_character() {
  id_character_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 create_character_out::_internal_id_character() const {
  return id_character_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 create_character_out::id_character() const {
  // @@protoc_insertion_point(field_get:mud.create_character_out.id_character)
  return _internal_id_character();
}
inline void create_character_out::_internal_set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_character_ = value;
}
inline void create_character_out::set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_character(value);
  // @@protoc_insertion_point(field_set:mud.create_character_out.id_character)
}

// repeated .mud.character characters = 3;
inline int create_character_out::_internal_characters_size() const {
  return characters_.size();
}
inline int create_character_out::characters_size() const {
  return _internal_characters_size();
}
inline ::mud::character* create_character_out::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:mud.create_character_out.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
create_character_out::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:mud.create_character_out.characters)
  return &characters_;
}
inline const ::mud::character& create_character_out::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::mud::character& create_character_out::characters(int index) const {
  // @@protoc_insertion_point(field_get:mud.create_character_out.characters)
  return _internal_characters(index);
}
inline ::mud::character* create_character_out::_internal_add_characters() {
  return characters_.Add();
}
inline ::mud::character* create_character_out::add_characters() {
  // @@protoc_insertion_point(field_add:mud.create_character_out.characters)
  return _internal_add_characters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
create_character_out::characters() const {
  // @@protoc_insertion_point(field_list:mud.create_character_out.characters)
  return characters_;
}

// -------------------------------------------------------------------

// play_in

// int64 id_token = 1;
inline void play_in::clear_id_token() {
  id_token_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::_internal_id_token() const {
  return id_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::id_token() const {
  // @@protoc_insertion_point(field_get:mud.play_in.id_token)
  return _internal_id_token();
}
inline void play_in::_internal_set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_token_ = value;
}
inline void play_in::set_id_token(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_token(value);
  // @@protoc_insertion_point(field_set:mud.play_in.id_token)
}

// int64 id_player = 2;
inline void play_in::clear_id_player() {
  id_player_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::_internal_id_player() const {
  return id_player_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::id_player() const {
  // @@protoc_insertion_point(field_get:mud.play_in.id_player)
  return _internal_id_player();
}
inline void play_in::_internal_set_id_player(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_player_ = value;
}
inline void play_in::set_id_player(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_player(value);
  // @@protoc_insertion_point(field_set:mud.play_in.id_player)
}

// int64 id_character = 3;
inline void play_in::clear_id_character() {
  id_character_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::_internal_id_character() const {
  return id_character_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_in::id_character() const {
  // @@protoc_insertion_point(field_get:mud.play_in.id_character)
  return _internal_id_character();
}
inline void play_in::_internal_set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_character_ = value;
}
inline void play_in::set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_character(value);
  // @@protoc_insertion_point(field_set:mud.play_in.id_character)
}

// .mud.play_in.command_enum command = 4;
inline void play_in::clear_command() {
  command_ = 0;
}
inline ::mud::play_in_command_enum play_in::_internal_command() const {
  return static_cast< ::mud::play_in_command_enum >(command_);
}
inline ::mud::play_in_command_enum play_in::command() const {
  // @@protoc_insertion_point(field_get:mud.play_in.command)
  return _internal_command();
}
inline void play_in::_internal_set_command(::mud::play_in_command_enum value) {
  
  command_ = value;
}
inline void play_in::set_command(::mud::play_in_command_enum value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:mud.play_in.command)
}

// -------------------------------------------------------------------

// play_out

// int64 id_character = 1;
inline void play_out::clear_id_character() {
  id_character_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_out::_internal_id_character() const {
  return id_character_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 play_out::id_character() const {
  // @@protoc_insertion_point(field_get:mud.play_out.id_character)
  return _internal_id_character();
}
inline void play_out::_internal_set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_character_ = value;
}
inline void play_out::set_id_character(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id_character(value);
  // @@protoc_insertion_point(field_set:mud.play_out.id_character)
}

// .mud.play_out.status_enum status = 2;
inline void play_out::clear_status() {
  status_ = 0;
}
inline ::mud::play_out_status_enum play_out::_internal_status() const {
  return static_cast< ::mud::play_out_status_enum >(status_);
}
inline ::mud::play_out_status_enum play_out::status() const {
  // @@protoc_insertion_point(field_get:mud.play_out.status)
  return _internal_status();
}
inline void play_out::_internal_set_status(::mud::play_out_status_enum value) {
  
  status_ = value;
}
inline void play_out::set_status(::mud::play_out_status_enum value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:mud.play_out.status)
}

// repeated .mud.tile tiles = 3;
inline int play_out::_internal_tiles_size() const {
  return tiles_.size();
}
inline int play_out::tiles_size() const {
  return _internal_tiles_size();
}
inline ::mud::tile* play_out::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:mud.play_out.tiles)
  return tiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >*
play_out::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:mud.play_out.tiles)
  return &tiles_;
}
inline const ::mud::tile& play_out::_internal_tiles(int index) const {
  return tiles_.Get(index);
}
inline const ::mud::tile& play_out::tiles(int index) const {
  // @@protoc_insertion_point(field_get:mud.play_out.tiles)
  return _internal_tiles(index);
}
inline ::mud::tile* play_out::_internal_add_tiles() {
  return tiles_.Add();
}
inline ::mud::tile* play_out::add_tiles() {
  // @@protoc_insertion_point(field_add:mud.play_out.tiles)
  return _internal_add_tiles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::tile >&
play_out::tiles() const {
  // @@protoc_insertion_point(field_list:mud.play_out.tiles)
  return tiles_;
}

// repeated .mud.character characters = 4;
inline int play_out::_internal_characters_size() const {
  return characters_.size();
}
inline int play_out::characters_size() const {
  return _internal_characters_size();
}
inline ::mud::character* play_out::mutable_characters(int index) {
  // @@protoc_insertion_point(field_mutable:mud.play_out.characters)
  return characters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >*
play_out::mutable_characters() {
  // @@protoc_insertion_point(field_mutable_list:mud.play_out.characters)
  return &characters_;
}
inline const ::mud::character& play_out::_internal_characters(int index) const {
  return characters_.Get(index);
}
inline const ::mud::character& play_out::characters(int index) const {
  // @@protoc_insertion_point(field_get:mud.play_out.characters)
  return _internal_characters(index);
}
inline ::mud::character* play_out::_internal_add_characters() {
  return characters_.Add();
}
inline ::mud::character* play_out::add_characters() {
  // @@protoc_insertion_point(field_add:mud.play_out.characters)
  return _internal_add_characters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::character >&
play_out::characters() const {
  // @@protoc_insertion_point(field_list:mud.play_out.characters)
  return characters_;
}

// repeated .mud.enemy enemies = 5;
inline int play_out::_internal_enemies_size() const {
  return enemies_.size();
}
inline int play_out::enemies_size() const {
  return _internal_enemies_size();
}
inline ::mud::enemy* play_out::mutable_enemies(int index) {
  // @@protoc_insertion_point(field_mutable:mud.play_out.enemies)
  return enemies_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >*
play_out::mutable_enemies() {
  // @@protoc_insertion_point(field_mutable_list:mud.play_out.enemies)
  return &enemies_;
}
inline const ::mud::enemy& play_out::_internal_enemies(int index) const {
  return enemies_.Get(index);
}
inline const ::mud::enemy& play_out::enemies(int index) const {
  // @@protoc_insertion_point(field_get:mud.play_out.enemies)
  return _internal_enemies(index);
}
inline ::mud::enemy* play_out::_internal_add_enemies() {
  return enemies_.Add();
}
inline ::mud::enemy* play_out::add_enemies() {
  // @@protoc_insertion_point(field_add:mud.play_out.enemies)
  return _internal_add_enemies();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::enemy >&
play_out::enemies() const {
  // @@protoc_insertion_point(field_list:mud.play_out.enemies)
  return enemies_;
}

// repeated .mud.item items = 6;
inline int play_out::_internal_items_size() const {
  return items_.size();
}
inline int play_out::items_size() const {
  return _internal_items_size();
}
inline ::mud::item* play_out::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:mud.play_out.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::item >*
play_out::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:mud.play_out.items)
  return &items_;
}
inline const ::mud::item& play_out::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::mud::item& play_out::items(int index) const {
  // @@protoc_insertion_point(field_get:mud.play_out.items)
  return _internal_items(index);
}
inline ::mud::item* play_out::_internal_add_items() {
  return items_.Add();
}
inline ::mud::item* play_out::add_items() {
  // @@protoc_insertion_point(field_add:mud.play_out.items)
  return _internal_add_items();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mud::item >&
play_out::items() const {
  // @@protoc_insertion_point(field_list:mud.play_out.items)
  return items_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mud

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mud::login_out_status_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::login_out_status_enum>() {
  return ::mud::login_out_status_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::select_character_out_status_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::select_character_out_status_enum>() {
  return ::mud::select_character_out_status_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::create_character_out_status_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::create_character_out_status_enum>() {
  return ::mud::create_character_out_status_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::play_in_command_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::play_in_command_enum>() {
  return ::mud::play_in_command_enum_descriptor();
}
template <> struct is_proto_enum< ::mud::play_out_status_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mud::play_out_status_enum>() {
  return ::mud::play_out_status_enum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mud_5fgrpc_2eproto
